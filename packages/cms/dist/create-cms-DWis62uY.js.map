{"version":3,"file":"create-cms-DWis62uY.js","names":["contentType","file: string | null","dbInstance: DrizzleClient | null","possiblePaths: string[]","connectionString: string","user","storageInstance: StorageClient | null","contentType","authInstance: ReturnType<typeof betterAuth> | null","schema.user","schema.session","schema.account","schema.verification","session","updateData: Partial<typeof contentType.$inferInsert>","updateData: Partial<typeof contentEntry.$inferInsert>","updateData: Partial<typeof media.$inferInsert>","updates: Partial<typeof contentType.$inferInsert>","updatedSchema: ContentTypeSchema","errors: string[]","updates: Partial<typeof contentEntry.$inferInsert>","session: Session | null","user: User | null","defaultOptions: ResolvedCMSOptions","opts: ResolvedCMSOptions","initPromise: Promise<DrizzleClient | null> | null","db: DrizzleClient | null","body: unknown"],"sources":["../src/templates/root.ts","../src/admin-panel.ts","../src/get-router.ts","../src/db/schema.ts","../src/db/index.ts","../src/storage/index.ts","../src/auth/index.ts","../src/trpc/init.ts","../src/trpc/routers/content-type.ts","../src/trpc/routers/content-entry.ts","../src/trpc/routers/media.ts","../src/trpc/routers/setup.ts","../src/trpc/routers/collections.ts","../src/trpc/routers/entries.ts","../src/trpc/router.ts","../src/trpc/handler.ts","../src/create-cms.ts"],"sourcesContent":["export const htmlTemplate = ({\n  title,\n  body,\n}: {\n  title: string;\n  body: string;\n}): string => `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\" />\n  <title>${title}</title>\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n  <link rel=\"stylesheet\" href=\"/admin/static/bundle.css\" />\n  <style>\n    /* Ensure CMS root takes full viewport */\n    body, html {\n      margin: 0;\n      padding: 0;\n      height: 100%;\n    }\n    #cms-root {\n      min-height: 100vh;\n    }\n  </style>\n</head>\n<body>\n  ${body}\n</body>\n</html>`;\n","import { htmlTemplate } from \"./templates/root\";\n\nexport const renderAdminPanel = (): string => {\n  return htmlTemplate({\n    title: \"CMS Admin Panel\",\n    body: `\n      <div id=\"cms-root\"></div>\n      <script src=\"/admin/static/bundle.js\" type=\"module\"></script>\n    `,\n  });\n};\n","import { renderAdminPanel } from \"./admin-panel\";\nimport { readFile } from \"fs/promises\";\nimport { join } from \"path\";\n\ntype RouterOptions = {\n  basePath: string;\n};\n\n/**\n * Internal router for handling GET requests to the CMS\n */\nexport const runGetRouter = async (\n  req: Request,\n  opts: RouterOptions\n): Promise<Response> => {\n  const url = new URL(req.url);\n  const { pathname } = url;\n  const adminRoute = pathname.split(opts.basePath)[1] || \"\";\n\n  // Handle static assets\n  if (adminRoute.startsWith(\"/static/\")) {\n    const staticPath = adminRoute.replace(\"/static/\", \"\");\n\n    // Determine content type\n    let contentType = \"text/plain\";\n    if (staticPath.endsWith(\".js\")) {\n      contentType = \"application/javascript\";\n    } else if (staticPath.endsWith(\".css\")) {\n      contentType = \"text/css\";\n    } else if (staticPath.endsWith(\".json\")) {\n      contentType = \"application/json\";\n    }\n\n    try {\n      // Try multiple paths to find the static files\n      const possiblePaths = [\n        // When used as a package in node_modules\n        join(\n          process.cwd(),\n          \"node_modules\",\n          \"@turbulence\",\n          \"cms\",\n          \"static\",\n          staticPath\n        ),\n        // When running in monorepo development\n        join(\n          process.cwd(),\n          \"..\",\n          \"..\",\n          \"packages\",\n          \"cms\",\n          \"static\",\n          staticPath\n        ),\n        // Direct path (for development)\n        join(process.cwd(), \"packages\", \"cms\", \"static\", staticPath),\n      ];\n\n      let file: string | null = null;\n      for (const filePath of possiblePaths) {\n        try {\n          file = await readFile(filePath, \"utf-8\");\n          break;\n        } catch {\n          // Try next path\n        }\n      }\n\n      if (!file) {\n        throw new Error(\"File not found\");\n      }\n\n      return new Response(file, {\n        headers: {\n          \"Content-Type\": contentType,\n          \"Cache-Control\": \"no-store\",\n        },\n      });\n    } catch {\n      return new Response(\"Not Found\", {\n        status: 404,\n        headers: {\n          \"Content-Type\": \"text/plain\",\n          \"Cache-Control\": \"no-store\",\n        },\n      });\n    }\n  }\n\n  // Default: render the admin panel\n  return new Response(renderAdminPanel(), {\n    headers: {\n      \"Content-Type\": \"text/html\",\n      \"Cache-Control\": \"no-store\",\n    },\n  });\n};\n","import {\n  pgTable,\n  text,\n  timestamp,\n  boolean,\n  jsonb,\n  uuid,\n  integer,\n  uniqueIndex,\n} from \"drizzle-orm/pg-core\";\nimport { sql } from \"drizzle-orm\";\nimport { z } from \"zod\";\n\n// ============================================================================\n// User & Authentication Tables (for better-auth)\n// ============================================================================\n\n/**\n * User roles in the CMS\n * - superadmin: Full access, can manage other admins\n * - admin: Can manage content\n * - editor: Can edit content but not publish\n */\nexport const userRoleEnum = [\"superadmin\", \"admin\", \"editor\"] as const;\nexport type UserRole = (typeof userRoleEnum)[number];\n\nexport const user = pgTable(\n  \"cms_user\",\n  {\n    id: text(\"id\").primaryKey(),\n    name: text(\"name\").notNull(),\n    email: text(\"email\").notNull().unique(),\n    emailVerified: boolean(\"email_verified\").notNull().default(false),\n    image: text(\"image\"),\n    role: text(\"role\", { enum: userRoleEnum }).notNull().default(\"editor\"),\n    createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n    updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  },\n  (table) => [\n    // Partial unique index: only one superadmin can exist\n    uniqueIndex(\"cms_user_unique_superadmin\")\n      .on(table.role)\n      .where(sql`${table.role} = 'superadmin'`),\n  ]\n);\n\nexport const session = pgTable(\"cms_session\", {\n  id: text(\"id\").primaryKey(),\n  expiresAt: timestamp(\"expires_at\").notNull(),\n  token: text(\"token\").notNull().unique(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  ipAddress: text(\"ip_address\"),\n  userAgent: text(\"user_agent\"),\n  userId: text(\"user_id\")\n    .notNull()\n    .references(() => user.id, { onDelete: \"cascade\" }),\n});\n\nexport const account = pgTable(\"cms_account\", {\n  id: text(\"id\").primaryKey(),\n  accountId: text(\"account_id\").notNull(),\n  providerId: text(\"provider_id\").notNull(),\n  userId: text(\"user_id\")\n    .notNull()\n    .references(() => user.id, { onDelete: \"cascade\" }),\n  accessToken: text(\"access_token\"),\n  refreshToken: text(\"refresh_token\"),\n  idToken: text(\"id_token\"),\n  accessTokenExpiresAt: timestamp(\"access_token_expires_at\"),\n  refreshTokenExpiresAt: timestamp(\"refresh_token_expires_at\"),\n  scope: text(\"scope\"),\n  password: text(\"password\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\nexport const verification = pgTable(\"cms_verification\", {\n  id: text(\"id\").primaryKey(),\n  identifier: text(\"identifier\").notNull(),\n  value: text(\"value\").notNull(),\n  expiresAt: timestamp(\"expires_at\").notNull(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n});\n\n// ============================================================================\n// CMS Content Tables\n// ============================================================================\n\n/**\n * Content Types - Defines the structure of content (like a schema)\n * e.g., \"blog_post\", \"page\", \"product\"\n */\nexport const contentType = pgTable(\"cms_content_type\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  name: text(\"name\").notNull().unique(),\n  slug: text(\"slug\").notNull().unique(),\n  description: text(\"description\"),\n  // JSON Schema defining the fields for this content type\n  schema: jsonb(\"schema\").notNull().$type<ContentTypeSchema>(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  createdById: text(\"created_by_id\").references(() => user.id),\n});\n\n/**\n * Content Entries - Actual content data\n */\nexport const contentEntry = pgTable(\"cms_content_entry\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  contentTypeId: uuid(\"content_type_id\")\n    .notNull()\n    .references(() => contentType.id, { onDelete: \"cascade\" }),\n  // The actual content data, validated against the content type schema\n  data: jsonb(\"data\").notNull().$type<Record<string, unknown>>(),\n  status: text(\"status\", { enum: [\"draft\", \"published\", \"archived\"] })\n    .notNull()\n    .default(\"draft\"),\n  publishedAt: timestamp(\"published_at\"),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  createdById: text(\"created_by_id\").references(() => user.id),\n  updatedById: text(\"updated_by_id\").references(() => user.id),\n});\n\n/**\n * Media/Assets - Files stored in the bucket\n */\nexport const media = pgTable(\"cms_media\", {\n  id: uuid(\"id\").primaryKey().defaultRandom(),\n  filename: text(\"filename\").notNull(),\n  originalFilename: text(\"original_filename\").notNull(),\n  mimeType: text(\"mime_type\").notNull(),\n  size: integer(\"size\").notNull(), // in bytes\n  url: text(\"url\").notNull(),\n  bucketPath: text(\"bucket_path\").notNull(),\n  alt: text(\"alt\"),\n  caption: text(\"caption\"),\n  metadata: jsonb(\"metadata\").$type<Record<string, unknown>>(),\n  createdAt: timestamp(\"created_at\").notNull().defaultNow(),\n  updatedAt: timestamp(\"updated_at\").notNull().defaultNow(),\n  uploadedById: text(\"uploaded_by_id\").references(() => user.id),\n});\n\n// ============================================================================\n// Zod Schemas for JSONB validation\n// ============================================================================\n\n/**\n * Basic field types for collections\n * Starting with core types, will expand later\n */\nexport const fieldTypeEnum = [\"string\", \"number\", \"boolean\"] as const;\nexport type FieldType = (typeof fieldTypeEnum)[number];\n\n/**\n * Schema for defining a single field in a collection\n */\nexport const collectionFieldSchema = z.object({\n  /** Unique identifier for the field */\n  id: z.string(),\n  /** Display name for the field */\n  name: z.string().min(1),\n  /** Machine-readable key (used in data storage) */\n  key: z\n    .string()\n    .min(1)\n    .regex(/^[a-z][a-zA-Z0-9]*$/, \"Must be camelCase\"),\n  /** Field type */\n  type: z.enum(fieldTypeEnum),\n  /** Whether this field is required */\n  required: z.boolean().default(false),\n  /** Description/help text for editors */\n  description: z.string().optional(),\n  /** Default value for the field */\n  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),\n});\n\n/**\n * Schema for the collection's field configuration\n */\nexport const contentTypeSchemaValidator = z.object({\n  fields: z.array(collectionFieldSchema),\n});\n\nexport type CollectionField = z.infer<typeof collectionFieldSchema>;\nexport type ContentTypeSchema = z.infer<typeof contentTypeSchemaValidator>;\n\n/**\n * @deprecated Use collectionFieldSchema instead\n */\nexport const contentFieldSchema = collectionFieldSchema;\n\n// ============================================================================\n// Type exports for Drizzle\n// ============================================================================\n\nexport type User = typeof user.$inferSelect;\nexport type NewUser = typeof user.$inferInsert;\n\nexport type Session = typeof session.$inferSelect;\nexport type NewSession = typeof session.$inferInsert;\n\nexport type ContentType = typeof contentType.$inferSelect;\nexport type NewContentType = typeof contentType.$inferInsert;\n\nexport type ContentEntry = typeof contentEntry.$inferSelect;\nexport type NewContentEntry = typeof contentEntry.$inferInsert;\n\nexport type Media = typeof media.$inferSelect;\nexport type NewMedia = typeof media.$inferInsert;\n","import { drizzle } from \"drizzle-orm/node-postgres\";\nimport { migrate } from \"drizzle-orm/node-postgres/migrator\";\nimport type { NodePgDatabase } from \"drizzle-orm/node-postgres\";\nimport { join, dirname } from \"path\";\nimport { fileURLToPath } from \"url\";\nimport { existsSync } from \"fs\";\nimport * as schema from \"./schema\";\n\nexport type DrizzleClient = NodePgDatabase<typeof schema>;\n\nexport type DatabaseConfig =\n  | {\n      // Connection string\n      connectionString: string;\n      /**\n       * Automatically run migrations on startup\n       * @default true\n       */\n      autoMigrate?: boolean;\n    }\n  | {\n      // Individual connection parameters\n      host: string;\n      port?: number;\n      user: string;\n      password: string;\n      database: string;\n      ssl?: boolean;\n      /**\n       * Automatically run migrations on startup\n       * @default true\n       */\n      autoMigrate?: boolean;\n    };\n\nlet dbInstance: DrizzleClient | null = null;\nlet migrationRun = false;\n\n/**\n * Get the path to the migrations folder\n * Works both in development and when installed as a package\n */\nconst getMigrationsPath = (): string => {\n  const possiblePaths: string[] = [];\n\n  // Try to get __dirname equivalent in ESM\n  try {\n    const __filename = fileURLToPath(import.meta.url);\n    const __dirname = dirname(__filename);\n\n    // From dist folder (when built): dist/db/index.js -> drizzle\n    possiblePaths.push(join(__dirname, \"..\", \"..\", \"drizzle\"));\n\n    // From src folder (in dev with transpilation): src/db/index.ts -> drizzle\n    possiblePaths.push(join(__dirname, \"..\", \"..\", \"drizzle\"));\n  } catch {\n    // Ignore ESM path resolution errors\n  }\n\n  // Monorepo development paths\n  possiblePaths.push(join(process.cwd(), \"packages\", \"cms\", \"drizzle\"));\n  possiblePaths.push(\n    join(process.cwd(), \"..\", \"..\", \"packages\", \"cms\", \"drizzle\")\n  );\n\n  // When installed as a package in node_modules\n  possiblePaths.push(\n    join(process.cwd(), \"node_modules\", \"@turbulence\", \"cms\", \"drizzle\")\n  );\n\n  // Find the first path that exists\n  for (const path of possiblePaths) {\n    const journalPath = join(path, \"meta\", \"_journal.json\");\n    if (existsSync(journalPath)) {\n      console.log(`[CMS] Found migrations at: ${path}`);\n      return path;\n    }\n  }\n\n  // Log attempted paths for debugging\n  console.error(\n    \"[CMS] Could not find migrations folder. Tried:\",\n    possiblePaths\n  );\n\n  // Return the most likely path as fallback\n  return possiblePaths[0];\n};\n\n/**\n * Run schema migrations using Drizzle's migrator\n * Migrations are auto-generated from the schema using `drizzle-kit generate`\n */\nexport const runMigrations = async (db: DrizzleClient): Promise<void> => {\n  if (migrationRun) {\n    return;\n  }\n\n  console.log(\"[CMS] Running database migrations...\");\n\n  try {\n    const migrationsFolder = getMigrationsPath();\n\n    await migrate(db, {\n      migrationsFolder,\n    });\n\n    migrationRun = true;\n    console.log(\"[CMS] Database migrations complete.\");\n  } catch (error) {\n    console.error(\"[CMS] Migration error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Creates or returns existing database client\n */\nexport const createDatabase = async (\n  config: DatabaseConfig\n): Promise<DrizzleClient> => {\n  if (dbInstance) {\n    return dbInstance;\n  }\n\n  let connectionString: string;\n  const autoMigrate = config.autoMigrate ?? true;\n\n  if (\"connectionString\" in config) {\n    connectionString = config.connectionString;\n  } else {\n    const { host, port = 5432, user, password, database, ssl } = config;\n    connectionString = `postgresql://${user}:${password}@${host}:${port}/${database}${\n      ssl ? \"?sslmode=require\" : \"\"\n    }`;\n  }\n\n  dbInstance = drizzle(connectionString, { schema });\n\n  // Run migrations automatically if enabled\n  if (autoMigrate) {\n    await runMigrations(dbInstance);\n  }\n\n  return dbInstance;\n};\n\n/**\n * Get the current database instance\n * Throws if database hasn't been initialized\n */\nexport const getDatabase = (): DrizzleClient => {\n  if (!dbInstance) {\n    throw new Error(\n      \"Database not initialized. Call createDatabase() first or pass database config to createCMS().\"\n    );\n  }\n  return dbInstance;\n};\n\n/**\n * Set an external database instance (useful for testing or custom setup)\n */\nexport const setDatabase = (db: DrizzleClient): void => {\n  dbInstance = db;\n};\n\nexport { schema };\nexport * from \"./schema\";\n","import { z } from \"zod\";\n\n/**\n * Storage configuration for file uploads\n * Supports S3-compatible storage (AWS S3, Cloudflare R2, MinIO, etc.)\n */\nexport const storageConfigSchema = z.object({\n  /**\n   * The bucket endpoint URL\n   * e.g., \"https://s3.amazonaws.com\" or \"https://<account>.r2.cloudflarestorage.com\"\n   */\n  endpoint: z.url(),\n\n  /**\n   * The bucket name\n   */\n  bucket: z.string(),\n\n  /**\n   * Access key ID for authentication\n   */\n  accessKeyId: z.string(),\n\n  /**\n   * Secret access key for authentication\n   */\n  secretAccessKey: z.string(),\n\n  /**\n   * AWS region (optional for some S3-compatible services)\n   */\n  region: z.string().optional().default(\"auto\"),\n\n  /**\n   * Public URL prefix for accessing files\n   * e.g., \"https://cdn.example.com\" or \"https://<bucket>.s3.amazonaws.com\"\n   */\n  publicUrl: z.string().url().optional(),\n\n  /**\n   * Path prefix for all uploads within the bucket\n   * e.g., \"cms/uploads\" -> files stored as \"cms/uploads/filename.jpg\"\n   */\n  pathPrefix: z.string().optional().default(\"cms\"),\n});\n\nexport type StorageConfig = z.infer<typeof storageConfigSchema>;\n\nlet storageInstance: StorageClient | null = null;\n\nexport interface UploadResult {\n  url: string;\n  bucketPath: string;\n  filename: string;\n}\n\nexport interface StorageClient {\n  /**\n   * Upload a file to the storage bucket\n   */\n  upload(\n    file: File | Blob,\n    options?: {\n      filename?: string;\n      contentType?: string;\n      folder?: string;\n    }\n  ): Promise<UploadResult>;\n\n  /**\n   * Delete a file from the storage bucket\n   */\n  delete(bucketPath: string): Promise<void>;\n\n  /**\n   * Get a signed URL for temporary access\n   */\n  getSignedUrl(bucketPath: string, expiresIn?: number): Promise<string>;\n\n  /**\n   * Get the public URL for a file\n   */\n  getPublicUrl(bucketPath: string): string;\n}\n\n/**\n * Creates a storage client for S3-compatible storage\n */\nexport const createStorageClient = (config: StorageConfig): StorageClient => {\n  const validatedConfig = storageConfigSchema.parse(config);\n\n  const getPublicUrl = (bucketPath: string): string => {\n    if (validatedConfig.publicUrl) {\n      return `${validatedConfig.publicUrl}/${bucketPath}`;\n    }\n    return `${validatedConfig.endpoint}/${validatedConfig.bucket}/${bucketPath}`;\n  };\n\n  const generatePath = (filename: string, folder?: string): string => {\n    const prefix = validatedConfig.pathPrefix;\n    const timestamp = Date.now();\n    const randomId = Math.random().toString(36).substring(2, 8);\n    const safeFilename = filename.replace(/[^a-zA-Z0-9.-]/g, \"_\");\n\n    const parts = [prefix, folder, `${timestamp}-${randomId}-${safeFilename}`]\n      .filter(Boolean)\n      .join(\"/\");\n\n    return parts;\n  };\n\n  const upload = async (\n    file: File | Blob,\n    options?: {\n      filename?: string;\n      contentType?: string;\n      folder?: string;\n    }\n  ): Promise<UploadResult> => {\n    const filename =\n      options?.filename || (file instanceof File ? file.name : \"file\");\n    const contentType =\n      options?.contentType || file.type || \"application/octet-stream\";\n    const bucketPath = generatePath(filename, options?.folder);\n\n    // Create the upload URL\n    const uploadUrl = `${validatedConfig.endpoint}/${validatedConfig.bucket}/${bucketPath}`;\n\n    // Get file content as ArrayBuffer\n    const arrayBuffer = await file.arrayBuffer();\n\n    // Create authorization header using AWS Signature Version 4\n    // For simplicity, we'll use a basic PUT request\n    // In production, you'd want to use proper AWS4 signing or an SDK\n    const response = await fetch(uploadUrl, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": contentType,\n        \"Content-Length\": String(arrayBuffer.byteLength),\n        // Note: In production, you'd add proper AWS4 signature headers here\n        // For now, this assumes the bucket allows public uploads or uses presigned URLs\n      },\n      body: arrayBuffer,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        `Upload failed: ${response.status} ${response.statusText}`\n      );\n    }\n\n    return {\n      url: getPublicUrl(bucketPath),\n      bucketPath,\n      filename,\n    };\n  };\n\n  const deleteFile = async (bucketPath: string): Promise<void> => {\n    const deleteUrl = `${validatedConfig.endpoint}/${validatedConfig.bucket}/${bucketPath}`;\n\n    const response = await fetch(deleteUrl, {\n      method: \"DELETE\",\n      // Note: In production, add proper AWS4 signature headers\n    });\n\n    if (!response.ok && response.status !== 404) {\n      throw new Error(\n        `Delete failed: ${response.status} ${response.statusText}`\n      );\n    }\n  };\n\n  const getSignedUrl = async (\n    bucketPath: string,\n    _expiresIn: number = 3600\n  ): Promise<string> => {\n    // In a full implementation, this would generate a presigned URL\n    // For now, return the public URL\n    // TODO: Implement proper presigned URL generation\n    return getPublicUrl(bucketPath);\n  };\n\n  return {\n    upload,\n    delete: deleteFile,\n    getSignedUrl,\n    getPublicUrl,\n  };\n};\n\n/**\n * Initialize the storage client\n */\nexport const initStorage = (config: StorageConfig): StorageClient => {\n  storageInstance = createStorageClient(config);\n  return storageInstance;\n};\n\n/**\n * Get the current storage client\n */\nexport const getStorage = (): StorageClient => {\n  if (!storageInstance) {\n    throw new Error(\n      \"Storage not initialized. Call initStorage() first or pass storage config to createCMS().\"\n    );\n  }\n  return storageInstance;\n};\n\n/**\n * Set an external storage client (useful for testing)\n */\nexport const setStorage = (client: StorageClient): void => {\n  storageInstance = client;\n};\n","import { betterAuth } from \"better-auth\";\nimport { drizzleAdapter } from \"better-auth/adapters/drizzle\";\nimport type { DrizzleClient } from \"../db\";\nimport * as schema from \"../db/schema\";\n\nexport interface AuthConfig {\n  /**\n   * The base URL for the auth routes (relative to basePath)\n   * This is automatically set based on the CMS basePath\n   * @internal\n   */\n  authBasePath?: string;\n\n  /**\n   * Secret key for signing tokens\n   * Should be a random string at least 32 characters long\n   */\n  secret: string;\n\n  /**\n   * The base URL of your application\n   * e.g., \"https://example.com\" or \"http://localhost:3000\"\n   */\n  baseUrl: string;\n\n  /**\n   * Enable email/password authentication\n   * @default true\n   */\n  emailAndPassword?: boolean;\n\n  /**\n   * Trusted origins for CORS\n   */\n  trustedOrigins?: string[];\n\n  /**\n   * Social login providers\n   */\n  socialProviders?: {\n    github?: {\n      clientId: string;\n      clientSecret: string;\n    };\n    google?: {\n      clientId: string;\n      clientSecret: string;\n    };\n  };\n}\n\nlet authInstance: ReturnType<typeof betterAuth> | null = null;\n\n/**\n * Creates the better-auth instance\n */\nexport const createAuth = (db: DrizzleClient, config: AuthConfig) => {\n  const auth = betterAuth({\n    database: drizzleAdapter(db, {\n      provider: \"pg\",\n      schema: {\n        user: schema.user,\n        session: schema.session,\n        account: schema.account,\n        verification: schema.verification,\n      },\n    }),\n    basePath: config.authBasePath ?? \"/admin/api/auth\",\n    secret: config.secret,\n    baseURL: config.baseUrl,\n    trustedOrigins: config.trustedOrigins,\n    emailAndPassword: {\n      enabled: config.emailAndPassword ?? true,\n    },\n    socialProviders: {\n      ...(config.socialProviders?.github && {\n        github: {\n          clientId: config.socialProviders.github.clientId,\n          clientSecret: config.socialProviders.github.clientSecret,\n        },\n      }),\n      ...(config.socialProviders?.google && {\n        google: {\n          clientId: config.socialProviders.google.clientId,\n          clientSecret: config.socialProviders.google.clientSecret,\n        },\n      }),\n    },\n    session: {\n      expiresIn: 60 * 60 * 24 * 7, // 7 days\n      updateAge: 60 * 60 * 24, // 1 day\n    },\n  });\n\n  authInstance = auth;\n  return auth;\n};\n\n/**\n * Get the current auth instance\n */\nexport const getAuth = () => {\n  if (!authInstance) {\n    throw new Error(\n      \"Auth not initialized. Call createAuth() first or pass auth config to createCMS().\"\n    );\n  }\n  return authInstance;\n};\n\n/**\n * Get session from request using better-auth\n */\nexport const getSession = async (req: Request) => {\n  const auth = getAuth();\n  const session = await auth.api.getSession({\n    headers: req.headers,\n  });\n  return session;\n};\n\n/**\n * Verify if a request is authenticated\n */\nexport const isAuthenticated = async (req: Request): Promise<boolean> => {\n  try {\n    const session = await getSession(req);\n    return session !== null && session.session !== null;\n  } catch {\n    return false;\n  }\n};\n\nexport type Auth = ReturnType<typeof createAuth>;\n","import { initTRPC, TRPCError } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport type { Session, User } from \"../db/schema\";\n\n/**\n * Context for tRPC procedures\n */\nexport interface TRPCContext {\n  session: Session | null;\n  user: User | null;\n  req: Request;\n}\n\n/**\n * Create the tRPC instance with context\n */\nconst t = initTRPC.context<TRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof Error ? error.cause.message : undefined,\n      },\n    };\n  },\n});\n\n/**\n * Export reusable tRPC helpers\n */\nexport const createTRPCRouter = t.router;\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * Public (unauthenticated) procedure\n * Can be used by anyone, no session required\n */\nexport const publicProcedure = t.procedure;\n\n/**\n * Protected (authenticated) procedure\n * Requires a valid session\n */\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.session || !ctx.user) {\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"You must be logged in to access this resource\",\n    });\n  }\n\n  return next({\n    ctx: {\n      ...ctx,\n      // Infer that session and user are non-null\n      session: ctx.session,\n      user: ctx.user,\n    },\n  });\n});\n\n/**\n * Middleware for logging\n */\nexport const loggerMiddleware = t.middleware(async ({ path, type, next }) => {\n  const start = Date.now();\n  const result = await next();\n  const duration = Date.now() - start;\n\n  console.log(`[tRPC] ${type} ${path} - ${duration}ms`);\n\n  return result;\n});\n\nexport { t };\n","import { z } from \"zod\";\nimport { eq } from \"drizzle-orm\";\nimport { createTRPCRouter, publicProcedure, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport {\n  contentType,\n  contentTypeSchemaValidator,\n  type ContentTypeSchema,\n} from \"../../db/schema\";\n\nexport const contentTypeRouter = createTRPCRouter({\n  /**\n   * Get all content types (public - for content fetching)\n   */\n  list: publicProcedure.query(async () => {\n    const db = getDatabase();\n    const types = await db.select().from(contentType).orderBy(contentType.name);\n    return types;\n  }),\n\n  /**\n   * Get a single content type by slug (public)\n   */\n  getBySlug: publicProcedure\n    .input(z.object({ slug: z.string() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n      const [type] = await db\n        .select()\n        .from(contentType)\n        .where(eq(contentType.slug, input.slug))\n        .limit(1);\n\n      return type ?? null;\n    }),\n\n  /**\n   * Create a new content type (protected)\n   */\n  create: protectedProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(100),\n        slug: z\n          .string()\n          .min(1)\n          .max(100)\n          .regex(/^[a-z0-9-]+$/),\n        description: z.string().optional(),\n        schema: contentTypeSchemaValidator,\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [newType] = await db\n        .insert(contentType)\n        .values({\n          name: input.name,\n          slug: input.slug,\n          description: input.description,\n          schema: input.schema as ContentTypeSchema,\n          createdById: ctx.user.id,\n        })\n        .returning();\n\n      return newType;\n    }),\n\n  /**\n   * Update a content type (protected)\n   */\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        name: z.string().min(1).max(100).optional(),\n        description: z.string().optional(),\n        schema: contentTypeSchemaValidator.optional(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      const updateData: Partial<typeof contentType.$inferInsert> = {\n        updatedAt: new Date(),\n      };\n\n      if (input.name) updateData.name = input.name;\n      if (input.description !== undefined)\n        updateData.description = input.description;\n      if (input.schema) updateData.schema = input.schema as ContentTypeSchema;\n\n      const [updated] = await db\n        .update(contentType)\n        .set(updateData)\n        .where(eq(contentType.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Delete a content type (protected)\n   */\n  delete: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      await db.delete(contentType).where(eq(contentType.id, input.id));\n\n      return { success: true };\n    }),\n});\n","import { z } from \"zod\";\nimport { eq, desc, and } from \"drizzle-orm\";\nimport { createTRPCRouter, publicProcedure, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport { contentEntry, contentType } from \"../../db/schema\";\n\nexport const contentEntryRouter = createTRPCRouter({\n  /**\n   * Get all entries for a content type (public - for fetching content)\n   */\n  list: publicProcedure\n    .input(\n      z.object({\n        contentTypeSlug: z.string(),\n        status: z.enum([\"draft\", \"published\", \"archived\"]).optional(),\n        limit: z.number().min(1).max(100).optional().default(50),\n        offset: z.number().min(0).optional().default(0),\n      })\n    )\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get content type by slug\n      const [type] = await db\n        .select()\n        .from(contentType)\n        .where(eq(contentType.slug, input.contentTypeSlug))\n        .limit(1);\n\n      if (!type) {\n        return { entries: [], total: 0 };\n      }\n\n      const conditions = [eq(contentEntry.contentTypeId, type.id)];\n\n      if (input.status) {\n        conditions.push(eq(contentEntry.status, input.status));\n      }\n\n      const entries = await db\n        .select()\n        .from(contentEntry)\n        .where(and(...conditions))\n        .orderBy(desc(contentEntry.createdAt))\n        .limit(input.limit)\n        .offset(input.offset);\n\n      return { entries, total: entries.length };\n    }),\n\n  /**\n   * Get a single entry by ID (public)\n   */\n  getById: publicProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [entry] = await db\n        .select()\n        .from(contentEntry)\n        .where(eq(contentEntry.id, input.id))\n        .limit(1);\n\n      return entry ?? null;\n    }),\n\n  /**\n   * Create a new content entry (protected)\n   */\n  create: protectedProcedure\n    .input(\n      z.object({\n        contentTypeId: z.string().uuid(),\n        data: z.record(z.string(), z.unknown()),\n        status: z\n          .enum([\"draft\", \"published\", \"archived\"])\n          .optional()\n          .default(\"draft\"),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [newEntry] = await db\n        .insert(contentEntry)\n        .values({\n          contentTypeId: input.contentTypeId,\n          data: input.data,\n          status: input.status,\n          publishedAt: input.status === \"published\" ? new Date() : null,\n          createdById: ctx.user.id,\n          updatedById: ctx.user.id,\n        })\n        .returning();\n\n      return newEntry;\n    }),\n\n  /**\n   * Update a content entry (protected)\n   */\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        data: z.record(z.string(), z.unknown()).optional(),\n        status: z.enum([\"draft\", \"published\", \"archived\"]).optional(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const updateData: Partial<typeof contentEntry.$inferInsert> = {\n        updatedAt: new Date(),\n        updatedById: ctx.user.id,\n      };\n\n      if (input.data) updateData.data = input.data;\n      if (input.status) {\n        updateData.status = input.status;\n        if (input.status === \"published\") {\n          updateData.publishedAt = new Date();\n        }\n      }\n\n      const [updated] = await db\n        .update(contentEntry)\n        .set(updateData)\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Delete a content entry (protected)\n   */\n  delete: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      await db.delete(contentEntry).where(eq(contentEntry.id, input.id));\n\n      return { success: true };\n    }),\n\n  /**\n   * Publish an entry (protected)\n   */\n  publish: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [updated] = await db\n        .update(contentEntry)\n        .set({\n          status: \"published\",\n          publishedAt: new Date(),\n          updatedAt: new Date(),\n          updatedById: ctx.user.id,\n        })\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Unpublish an entry (protected)\n   */\n  unpublish: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [updated] = await db\n        .update(contentEntry)\n        .set({\n          status: \"draft\",\n          updatedAt: new Date(),\n          updatedById: ctx.user.id,\n        })\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n});\n","import { z } from \"zod\";\nimport { eq, desc } from \"drizzle-orm\";\nimport { createTRPCRouter, publicProcedure, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport { media } from \"../../db/schema\";\nimport { getStorage } from \"../../storage\";\n\nexport const mediaRouter = createTRPCRouter({\n  /**\n   * List all media files (public for fetching, but could be protected)\n   */\n  list: publicProcedure\n    .input(\n      z.object({\n        limit: z.number().min(1).max(100).optional().default(50),\n        offset: z.number().min(0).optional().default(0),\n        mimeType: z.string().optional(),\n      })\n    )\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      let query = db\n        .select()\n        .from(media)\n        .orderBy(desc(media.createdAt))\n        .limit(input.limit)\n        .offset(input.offset);\n\n      if (input.mimeType) {\n        query = query.where(eq(media.mimeType, input.mimeType)) as typeof query;\n      }\n\n      const files = await query;\n\n      return { files, total: files.length };\n    }),\n\n  /**\n   * Get a single media file by ID (public)\n   */\n  getById: publicProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [file] = await db\n        .select()\n        .from(media)\n        .where(eq(media.id, input.id))\n        .limit(1);\n\n      return file ?? null;\n    }),\n\n  /**\n   * Upload a new media file (protected)\n   * Note: The actual file upload happens via a separate endpoint\n   * This creates the database record after successful upload\n   */\n  create: protectedProcedure\n    .input(\n      z.object({\n        filename: z.string(),\n        originalFilename: z.string(),\n        mimeType: z.string(),\n        size: z.number(),\n        url: z.string().url(),\n        bucketPath: z.string(),\n        alt: z.string().optional(),\n        caption: z.string().optional(),\n        metadata: z.record(z.string(), z.unknown()).optional(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [newMedia] = await db\n        .insert(media)\n        .values({\n          filename: input.filename,\n          originalFilename: input.originalFilename,\n          mimeType: input.mimeType,\n          size: input.size,\n          url: input.url,\n          bucketPath: input.bucketPath,\n          alt: input.alt,\n          caption: input.caption,\n          metadata: input.metadata,\n          uploadedById: ctx.user.id,\n        })\n        .returning();\n\n      return newMedia;\n    }),\n\n  /**\n   * Update media metadata (protected)\n   */\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        alt: z.string().optional(),\n        caption: z.string().optional(),\n        metadata: z.record(z.string(), z.unknown()).optional(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      const updateData: Partial<typeof media.$inferInsert> = {\n        updatedAt: new Date(),\n      };\n\n      if (input.alt !== undefined) updateData.alt = input.alt;\n      if (input.caption !== undefined) updateData.caption = input.caption;\n      if (input.metadata) updateData.metadata = input.metadata;\n\n      const [updated] = await db\n        .update(media)\n        .set(updateData)\n        .where(eq(media.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Delete a media file (protected)\n   */\n  delete: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get the media record first to get the bucket path\n      const [mediaRecord] = await db\n        .select()\n        .from(media)\n        .where(eq(media.id, input.id))\n        .limit(1);\n\n      if (!mediaRecord) {\n        return { success: false, error: \"Media not found\" };\n      }\n\n      // Delete from storage\n      try {\n        const storage = getStorage();\n        await storage.delete(mediaRecord.bucketPath);\n      } catch (error) {\n        console.error(\"Failed to delete file from storage:\", error);\n        // Continue with database deletion even if storage deletion fails\n      }\n\n      // Delete from database\n      await db.delete(media).where(eq(media.id, input.id));\n\n      return { success: true };\n    }),\n\n  /**\n   * Get a signed URL for a media file (protected)\n   */\n  getSignedUrl: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        expiresIn: z.number().optional().default(3600),\n      })\n    )\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [mediaRecord] = await db\n        .select()\n        .from(media)\n        .where(eq(media.id, input.id))\n        .limit(1);\n\n      if (!mediaRecord) {\n        return null;\n      }\n\n      const storage = getStorage();\n      const signedUrl = await storage.getSignedUrl(\n        mediaRecord.bucketPath,\n        input.expiresIn\n      );\n\n      return { url: signedUrl };\n    }),\n});\n","import { z } from \"zod\";\nimport { eq } from \"drizzle-orm\";\nimport { createTRPCRouter, publicProcedure, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport { user } from \"../../db/schema\";\nimport { getAuth } from \"../../auth\";\n\nexport const setupRouter = createTRPCRouter({\n  /**\n   * Check if the CMS has been set up (has a superadmin)\n   * This is a public endpoint so the client can show the right page\n   */\n  getStatus: publicProcedure.query(async () => {\n    try {\n      const db = getDatabase();\n\n      // Check if any superadmin exists\n      const [superadmin] = await db\n        .select({ id: user.id })\n        .from(user)\n        .where(eq(user.role, \"superadmin\"))\n        .limit(1);\n\n      return {\n        isSetupComplete: !!superadmin,\n        hasSuperadmin: !!superadmin,\n      };\n    } catch (error) {\n      // Database might not be configured yet\n      console.error(\"Setup status check failed:\", error);\n      return {\n        isSetupComplete: false,\n        hasSuperadmin: false,\n        error: \"Database not configured\",\n      };\n    }\n  }),\n\n  /**\n   * Create the first superadmin user\n   * This can only be called once - when no superadmin exists\n   * Database enforces this with a partial unique index\n   */\n  createSuperadmin: publicProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(100),\n        email: z.string().email(),\n        password: z.string().min(8).max(100),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Check if superadmin already exists\n      const [existingSuperadmin] = await db\n        .select({ id: user.id })\n        .from(user)\n        .where(eq(user.role, \"superadmin\"))\n        .limit(1);\n\n      if (existingSuperadmin) {\n        throw new Error(\"Setup already complete. A superadmin already exists.\");\n      }\n\n      // Use better-auth to create the user with email/password\n      const auth = getAuth();\n\n      // Sign up the user through better-auth\n      const signUpResult = await auth.api.signUpEmail({\n        body: {\n          name: input.name,\n          email: input.email,\n          password: input.password,\n        },\n      });\n\n      if (!signUpResult || !signUpResult.user) {\n        throw new Error(\"Failed to create user account\");\n      }\n\n      // Update the user to be a superadmin\n      // The database has a partial unique index that ensures only one superadmin exists\n      try {\n        await db\n          .update(user)\n          .set({\n            role: \"superadmin\",\n            updatedAt: new Date(),\n          })\n          .where(eq(user.id, signUpResult.user.id));\n      } catch (error) {\n        // If the unique constraint fails, another superadmin was created in a race condition\n        // Delete the user we just created since they can't be superadmin\n        await db.delete(user).where(eq(user.id, signUpResult.user.id));\n        throw new Error(\"Setup already complete. A superadmin already exists.\");\n      }\n\n      return {\n        success: true,\n        message: \"Superadmin created successfully\",\n        user: {\n          id: signUpResult.user.id,\n          name: signUpResult.user.name,\n          email: signUpResult.user.email,\n        },\n      };\n    }),\n\n  /**\n   * Get current user's role (protected)\n   */\n  getMyRole: protectedProcedure.query(async ({ ctx }) => {\n    const db = getDatabase();\n\n    const [userData] = await db\n      .select({ role: user.role })\n      .from(user)\n      .where(eq(user.id, ctx.user.id))\n      .limit(1);\n\n    return {\n      role: userData?.role ?? \"editor\",\n      isSuperadmin: userData?.role === \"superadmin\",\n      isAdmin: userData?.role === \"admin\" || userData?.role === \"superadmin\",\n    };\n  }),\n\n  /**\n   * Invite a new admin (superadmin only)\n   */\n  inviteAdmin: protectedProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(100),\n        email: z.string().email(),\n        password: z.string().min(8).max(100),\n        role: z.enum([\"admin\", \"editor\"]),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      // Check if current user is superadmin\n      const [currentUser] = await db\n        .select({ role: user.role })\n        .from(user)\n        .where(eq(user.id, ctx.user.id))\n        .limit(1);\n\n      if (currentUser?.role !== \"superadmin\") {\n        throw new Error(\"Only superadmins can invite new admins\");\n      }\n\n      // Check if email already exists\n      const [existingUser] = await db\n        .select({ id: user.id })\n        .from(user)\n        .where(eq(user.email, input.email))\n        .limit(1);\n\n      if (existingUser) {\n        throw new Error(\"A user with this email already exists\");\n      }\n\n      // Create the user through better-auth\n      const auth = getAuth();\n\n      const signUpResult = await auth.api.signUpEmail({\n        body: {\n          name: input.name,\n          email: input.email,\n          password: input.password,\n        },\n      });\n\n      if (!signUpResult || !signUpResult.user) {\n        throw new Error(\"Failed to create user account\");\n      }\n\n      // Update the user role\n      await db\n        .update(user)\n        .set({\n          role: input.role,\n          updatedAt: new Date(),\n        })\n        .where(eq(user.id, signUpResult.user.id));\n\n      return {\n        success: true,\n        user: {\n          id: signUpResult.user.id,\n          name: signUpResult.user.name,\n          email: signUpResult.user.email,\n          role: input.role,\n        },\n      };\n    }),\n\n  /**\n   * List all admins (superadmin only)\n   */\n  listAdmins: protectedProcedure.query(async ({ ctx }) => {\n    const db = getDatabase();\n\n    // Check if current user is superadmin\n    const [currentUser] = await db\n      .select({ role: user.role })\n      .from(user)\n      .where(eq(user.id, ctx.user.id))\n      .limit(1);\n\n    if (currentUser?.role !== \"superadmin\") {\n      throw new Error(\"Only superadmins can view admin list\");\n    }\n\n    const admins = await db\n      .select({\n        id: user.id,\n        name: user.name,\n        email: user.email,\n        role: user.role,\n        createdAt: user.createdAt,\n      })\n      .from(user)\n      .orderBy(user.createdAt);\n\n    return { admins };\n  }),\n});\n","import { z } from \"zod\";\nimport { eq } from \"drizzle-orm\";\nimport { createTRPCRouter, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport {\n  contentType,\n  collectionFieldSchema,\n  contentTypeSchemaValidator,\n  type ContentTypeSchema,\n} from \"../../db/schema\";\n\n/**\n * Generate a URL-friendly slug from a name\n */\nfunction generateSlug(name: string): string {\n  return name\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, \"-\")\n    .replace(/^-|-$/g, \"\");\n}\n\n/**\n * Generate a unique ID for fields\n */\nfunction generateFieldId(): string {\n  return `field_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n}\n\nexport const collectionsRouter = createTRPCRouter({\n  /**\n   * List all collections\n   */\n  list: protectedProcedure.query(async () => {\n    const db = getDatabase();\n\n    const collections = await db\n      .select({\n        id: contentType.id,\n        name: contentType.name,\n        slug: contentType.slug,\n        description: contentType.description,\n        schema: contentType.schema,\n        createdAt: contentType.createdAt,\n        updatedAt: contentType.updatedAt,\n      })\n      .from(contentType)\n      .orderBy(contentType.name);\n\n    return collections;\n  }),\n\n  /**\n   * Get a single collection by ID\n   */\n  getById: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [collection] = await db\n        .select()\n        .from(contentType)\n        .where(eq(contentType.id, input.id))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      return collection;\n    }),\n\n  /**\n   * Get a single collection by slug\n   */\n  getBySlug: protectedProcedure\n    .input(z.object({ slug: z.string() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [collection] = await db\n        .select()\n        .from(contentType)\n        .where(eq(contentType.slug, input.slug))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      return collection;\n    }),\n\n  /**\n   * Create a new collection\n   */\n  create: protectedProcedure\n    .input(\n      z.object({\n        name: z.string().min(1).max(100),\n        description: z.string().optional(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const slug = generateSlug(input.name);\n\n      // Check if slug already exists\n      const [existing] = await db\n        .select({ id: contentType.id })\n        .from(contentType)\n        .where(eq(contentType.slug, slug))\n        .limit(1);\n\n      if (existing) {\n        throw new Error(`A collection with the slug \"${slug}\" already exists`);\n      }\n\n      // Create with empty schema\n      const schema: ContentTypeSchema = { fields: [] };\n\n      const [collection] = await db\n        .insert(contentType)\n        .values({\n          name: input.name,\n          slug,\n          description: input.description,\n          schema,\n          createdById: ctx.user.id,\n        })\n        .returning();\n\n      return collection;\n    }),\n\n  /**\n   * Update collection metadata (name, description)\n   */\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        name: z.string().min(1).max(100).optional(),\n        description: z.string().optional(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      const updates: Partial<typeof contentType.$inferInsert> = {\n        updatedAt: new Date(),\n      };\n\n      if (input.name) {\n        updates.name = input.name;\n        updates.slug = generateSlug(input.name);\n\n        // Check if new slug already exists (excluding current)\n        const [existing] = await db\n          .select({ id: contentType.id })\n          .from(contentType)\n          .where(eq(contentType.slug, updates.slug))\n          .limit(1);\n\n        if (existing && existing.id !== input.id) {\n          throw new Error(\n            `A collection with the slug \"${updates.slug}\" already exists`\n          );\n        }\n      }\n\n      if (input.description !== undefined) {\n        updates.description = input.description;\n      }\n\n      const [collection] = await db\n        .update(contentType)\n        .set(updates)\n        .where(eq(contentType.id, input.id))\n        .returning();\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      return collection;\n    }),\n\n  /**\n   * Delete a collection\n   */\n  delete: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      const [deleted] = await db\n        .delete(contentType)\n        .where(eq(contentType.id, input.id))\n        .returning({ id: contentType.id });\n\n      if (!deleted) {\n        throw new Error(\"Collection not found\");\n      }\n\n      return { success: true };\n    }),\n\n  /**\n   * Update the schema (fields) for a collection\n   */\n  updateSchema: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        schema: contentTypeSchemaValidator,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Validate field keys are unique\n      const keys = input.schema.fields.map((f) => f.key);\n      if (new Set(keys).size !== keys.length) {\n        throw new Error(\"Field keys must be unique\");\n      }\n\n      const [collection] = await db\n        .update(contentType)\n        .set({\n          schema: input.schema,\n          updatedAt: new Date(),\n        })\n        .where(eq(contentType.id, input.id))\n        .returning();\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      return collection;\n    }),\n\n  /**\n   * Add a field to a collection's schema\n   */\n  addField: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        field: collectionFieldSchema.omit({ id: true }),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get current schema\n      const [collection] = await db\n        .select({ schema: contentType.schema })\n        .from(contentType)\n        .where(eq(contentType.id, input.collectionId))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      const currentSchema = collection.schema as ContentTypeSchema;\n\n      // Check if key already exists\n      if (currentSchema.fields.some((f) => f.key === input.field.key)) {\n        throw new Error(`A field with key \"${input.field.key}\" already exists`);\n      }\n\n      // Add new field with generated ID\n      const newField = {\n        ...input.field,\n        id: generateFieldId(),\n      };\n\n      const updatedSchema: ContentTypeSchema = {\n        fields: [...currentSchema.fields, newField],\n      };\n\n      const [updated] = await db\n        .update(contentType)\n        .set({\n          schema: updatedSchema,\n          updatedAt: new Date(),\n        })\n        .where(eq(contentType.id, input.collectionId))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Update a field in a collection's schema\n   */\n  updateField: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        fieldId: z.string(),\n        updates: collectionFieldSchema.partial().omit({ id: true }),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get current schema\n      const [collection] = await db\n        .select({ schema: contentType.schema })\n        .from(contentType)\n        .where(eq(contentType.id, input.collectionId))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      const currentSchema = collection.schema as ContentTypeSchema;\n\n      // Find and update the field\n      const fieldIndex = currentSchema.fields.findIndex(\n        (f) => f.id === input.fieldId\n      );\n\n      if (fieldIndex === -1) {\n        throw new Error(\"Field not found\");\n      }\n\n      // If updating key, check for uniqueness\n      if (\n        input.updates.key &&\n        currentSchema.fields.some(\n          (f, i) => i !== fieldIndex && f.key === input.updates.key\n        )\n      ) {\n        throw new Error(\n          `A field with key \"${input.updates.key}\" already exists`\n        );\n      }\n\n      const updatedFields = [...currentSchema.fields];\n      updatedFields[fieldIndex] = {\n        ...updatedFields[fieldIndex],\n        ...input.updates,\n      };\n\n      const updatedSchema: ContentTypeSchema = {\n        fields: updatedFields,\n      };\n\n      const [updated] = await db\n        .update(contentType)\n        .set({\n          schema: updatedSchema,\n          updatedAt: new Date(),\n        })\n        .where(eq(contentType.id, input.collectionId))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Remove a field from a collection's schema\n   */\n  removeField: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        fieldId: z.string(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get current schema\n      const [collection] = await db\n        .select({ schema: contentType.schema })\n        .from(contentType)\n        .where(eq(contentType.id, input.collectionId))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      const currentSchema = collection.schema as ContentTypeSchema;\n\n      const updatedSchema: ContentTypeSchema = {\n        fields: currentSchema.fields.filter((f) => f.id !== input.fieldId),\n      };\n\n      const [updated] = await db\n        .update(contentType)\n        .set({\n          schema: updatedSchema,\n          updatedAt: new Date(),\n        })\n        .where(eq(contentType.id, input.collectionId))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Reorder fields in a collection's schema\n   */\n  reorderFields: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        fieldIds: z.array(z.string()),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      // Get current schema\n      const [collection] = await db\n        .select({ schema: contentType.schema })\n        .from(contentType)\n        .where(eq(contentType.id, input.collectionId))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      const currentSchema = collection.schema as ContentTypeSchema;\n\n      // Reorder fields according to the provided order\n      const fieldMap = new Map(currentSchema.fields.map((f) => [f.id, f]));\n      const reorderedFields = input.fieldIds\n        .map((id) => fieldMap.get(id))\n        .filter((f): f is NonNullable<typeof f> => f !== undefined);\n\n      // Add any fields that weren't in the order list at the end\n      for (const field of currentSchema.fields) {\n        if (!input.fieldIds.includes(field.id)) {\n          reorderedFields.push(field);\n        }\n      }\n\n      const updatedSchema: ContentTypeSchema = {\n        fields: reorderedFields,\n      };\n\n      const [updated] = await db\n        .update(contentType)\n        .set({\n          schema: updatedSchema,\n          updatedAt: new Date(),\n        })\n        .where(eq(contentType.id, input.collectionId))\n        .returning();\n\n      return updated;\n    }),\n});\n","import { z } from \"zod\";\nimport { eq, and, desc, asc, sql } from \"drizzle-orm\";\nimport { createTRPCRouter, protectedProcedure } from \"../init\";\nimport { getDatabase } from \"../../db\";\nimport {\n  contentType,\n  contentEntry,\n  type ContentTypeSchema,\n  type CollectionField,\n} from \"../../db/schema\";\n\n/**\n * Validate entry data against the collection schema\n */\nfunction validateEntryData(\n  data: Record<string, unknown>,\n  schema: ContentTypeSchema\n): { valid: boolean; errors: string[] } {\n  const errors: string[] = [];\n\n  for (const field of schema.fields) {\n    const value = data[field.key];\n\n    // Check required fields\n    if (\n      field.required &&\n      (value === undefined || value === null || value === \"\")\n    ) {\n      errors.push(`Field \"${field.name}\" is required`);\n      continue;\n    }\n\n    // Skip validation if value is empty and not required\n    if (value === undefined || value === null || value === \"\") {\n      continue;\n    }\n\n    // Type validation\n    switch (field.type) {\n      case \"string\":\n        if (typeof value !== \"string\") {\n          errors.push(`Field \"${field.name}\" must be a string`);\n        }\n        break;\n      case \"number\":\n        if (typeof value !== \"number\" || isNaN(value)) {\n          errors.push(`Field \"${field.name}\" must be a number`);\n        }\n        break;\n      case \"boolean\":\n        if (typeof value !== \"boolean\") {\n          errors.push(`Field \"${field.name}\" must be a boolean`);\n        }\n        break;\n    }\n  }\n\n  return { valid: errors.length === 0, errors };\n}\n\n/**\n * Apply default values from schema to entry data\n */\nfunction applyDefaults(\n  data: Record<string, unknown>,\n  schema: ContentTypeSchema\n): Record<string, unknown> {\n  const result = { ...data };\n\n  for (const field of schema.fields) {\n    if (\n      (result[field.key] === undefined || result[field.key] === null) &&\n      field.defaultValue !== undefined\n    ) {\n      result[field.key] = field.defaultValue;\n    }\n  }\n\n  return result;\n}\n\nexport const entriesRouter = createTRPCRouter({\n  /**\n   * List entries for a collection\n   */\n  list: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        status: z.enum([\"draft\", \"published\", \"archived\"]).optional(),\n        limit: z.number().min(1).max(100).default(50),\n        offset: z.number().min(0).default(0),\n        orderBy: z.enum([\"createdAt\", \"updatedAt\"]).default(\"createdAt\"),\n        orderDir: z.enum([\"asc\", \"desc\"]).default(\"desc\"),\n      })\n    )\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      // Build conditions\n      const conditions = [eq(contentEntry.contentTypeId, input.collectionId)];\n\n      if (input.status) {\n        conditions.push(eq(contentEntry.status, input.status));\n      }\n\n      // Get entries\n      const entries = await db\n        .select({\n          id: contentEntry.id,\n          data: contentEntry.data,\n          status: contentEntry.status,\n          publishedAt: contentEntry.publishedAt,\n          createdAt: contentEntry.createdAt,\n          updatedAt: contentEntry.updatedAt,\n        })\n        .from(contentEntry)\n        .where(and(...conditions))\n        .orderBy(\n          input.orderDir === \"desc\"\n            ? desc(contentEntry[input.orderBy])\n            : asc(contentEntry[input.orderBy])\n        )\n        .limit(input.limit)\n        .offset(input.offset);\n\n      // Get total count\n      const [{ count }] = await db\n        .select({ count: sql<number>`count(*)::int` })\n        .from(contentEntry)\n        .where(and(...conditions));\n\n      return {\n        entries,\n        total: count,\n        limit: input.limit,\n        offset: input.offset,\n      };\n    }),\n\n  /**\n   * Get a single entry by ID\n   */\n  getById: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .query(async ({ input }) => {\n      const db = getDatabase();\n\n      const [entry] = await db\n        .select()\n        .from(contentEntry)\n        .where(eq(contentEntry.id, input.id))\n        .limit(1);\n\n      if (!entry) {\n        throw new Error(\"Entry not found\");\n      }\n\n      return entry;\n    }),\n\n  /**\n   * Create a new entry\n   */\n  create: protectedProcedure\n    .input(\n      z.object({\n        collectionId: z.string().uuid(),\n        data: z.record(z.string(), z.unknown()),\n        status: z.enum([\"draft\", \"published\"]).default(\"draft\"),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      // Get the collection schema\n      const [collection] = await db\n        .select({ schema: contentType.schema })\n        .from(contentType)\n        .where(eq(contentType.id, input.collectionId))\n        .limit(1);\n\n      if (!collection) {\n        throw new Error(\"Collection not found\");\n      }\n\n      const schema = collection.schema as ContentTypeSchema;\n\n      // Apply defaults\n      const dataWithDefaults = applyDefaults(input.data, schema);\n\n      // Validate data against schema\n      const validation = validateEntryData(dataWithDefaults, schema);\n      if (!validation.valid) {\n        throw new Error(`Validation failed: ${validation.errors.join(\", \")}`);\n      }\n\n      const [entry] = await db\n        .insert(contentEntry)\n        .values({\n          contentTypeId: input.collectionId,\n          data: dataWithDefaults,\n          status: input.status,\n          publishedAt: input.status === \"published\" ? new Date() : null,\n          createdById: ctx.user.id,\n          updatedById: ctx.user.id,\n        })\n        .returning();\n\n      return entry;\n    }),\n\n  /**\n   * Update an entry\n   */\n  update: protectedProcedure\n    .input(\n      z.object({\n        id: z.string().uuid(),\n        data: z.record(z.string(), z.unknown()).optional(),\n        status: z.enum([\"draft\", \"published\", \"archived\"]).optional(),\n      })\n    )\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      // Get the entry and its collection schema\n      const [entry] = await db\n        .select({\n          entry: contentEntry,\n          schema: contentType.schema,\n        })\n        .from(contentEntry)\n        .innerJoin(contentType, eq(contentEntry.contentTypeId, contentType.id))\n        .where(eq(contentEntry.id, input.id))\n        .limit(1);\n\n      if (!entry) {\n        throw new Error(\"Entry not found\");\n      }\n\n      const schema = entry.schema as ContentTypeSchema;\n\n      // Prepare updates\n      const updates: Partial<typeof contentEntry.$inferInsert> = {\n        updatedAt: new Date(),\n        updatedById: ctx.user.id,\n      };\n\n      if (input.data) {\n        // Merge with existing data and apply defaults\n        const mergedData = { ...entry.entry.data, ...input.data };\n        const dataWithDefaults = applyDefaults(mergedData, schema);\n\n        // Validate\n        const validation = validateEntryData(dataWithDefaults, schema);\n        if (!validation.valid) {\n          throw new Error(`Validation failed: ${validation.errors.join(\", \")}`);\n        }\n\n        updates.data = dataWithDefaults;\n      }\n\n      if (input.status) {\n        updates.status = input.status;\n\n        // Set publishedAt when publishing\n        if (\n          input.status === \"published\" &&\n          entry.entry.status !== \"published\"\n        ) {\n          updates.publishedAt = new Date();\n        }\n      }\n\n      const [updated] = await db\n        .update(contentEntry)\n        .set(updates)\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      return updated;\n    }),\n\n  /**\n   * Delete an entry\n   */\n  delete: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      const [deleted] = await db\n        .delete(contentEntry)\n        .where(eq(contentEntry.id, input.id))\n        .returning({ id: contentEntry.id });\n\n      if (!deleted) {\n        throw new Error(\"Entry not found\");\n      }\n\n      return { success: true };\n    }),\n\n  /**\n   * Publish an entry\n   */\n  publish: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [entry] = await db\n        .update(contentEntry)\n        .set({\n          status: \"published\",\n          publishedAt: new Date(),\n          updatedAt: new Date(),\n          updatedById: ctx.user.id,\n        })\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      if (!entry) {\n        throw new Error(\"Entry not found\");\n      }\n\n      return entry;\n    }),\n\n  /**\n   * Unpublish an entry (set to draft)\n   */\n  unpublish: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [entry] = await db\n        .update(contentEntry)\n        .set({\n          status: \"draft\",\n          updatedAt: new Date(),\n          updatedById: ctx.user.id,\n        })\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      if (!entry) {\n        throw new Error(\"Entry not found\");\n      }\n\n      return entry;\n    }),\n\n  /**\n   * Archive an entry\n   */\n  archive: protectedProcedure\n    .input(z.object({ id: z.string().uuid() }))\n    .mutation(async ({ input, ctx }) => {\n      const db = getDatabase();\n\n      const [entry] = await db\n        .update(contentEntry)\n        .set({\n          status: \"archived\",\n          updatedAt: new Date(),\n          updatedById: ctx.user.id,\n        })\n        .where(eq(contentEntry.id, input.id))\n        .returning();\n\n      if (!entry) {\n        throw new Error(\"Entry not found\");\n      }\n\n      return entry;\n    }),\n\n  /**\n   * Bulk delete entries\n   */\n  bulkDelete: protectedProcedure\n    .input(z.object({ ids: z.array(z.string().uuid()) }))\n    .mutation(async ({ input }) => {\n      const db = getDatabase();\n\n      let deletedCount = 0;\n\n      for (const id of input.ids) {\n        const [deleted] = await db\n          .delete(contentEntry)\n          .where(eq(contentEntry.id, id))\n          .returning({ id: contentEntry.id });\n\n        if (deleted) {\n          deletedCount++;\n        }\n      }\n\n      return { deletedCount };\n    }),\n});\n","import { createTRPCRouter, publicProcedure, protectedProcedure } from \"./init\";\nimport { contentTypeRouter } from \"./routers/content-type\";\nimport { contentEntryRouter } from \"./routers/content-entry\";\nimport { mediaRouter } from \"./routers/media\";\nimport { setupRouter } from \"./routers/setup\";\nimport { collectionsRouter } from \"./routers/collections\";\nimport { entriesRouter } from \"./routers/entries\";\n\n/**\n * Main CMS API Router\n */\nexport const appRouter = createTRPCRouter({\n  /**\n   * Setup and admin management\n   */\n  setup: setupRouter,\n\n  /**\n   * Collections (new API for schema + content management)\n   */\n  collections: collectionsRouter,\n\n  /**\n   * Entries (new API for content entries)\n   */\n  entries: entriesRouter,\n\n  /**\n   * Content types (schemas) - legacy, use collections instead\n   */\n  contentType: contentTypeRouter,\n\n  /**\n   * Content entries (actual data) - legacy, use entries instead\n   */\n  contentEntry: contentEntryRouter,\n\n  /**\n   * Media/file management\n   */\n  media: mediaRouter,\n\n  /**\n   * Example public endpoint - health check\n   */\n  health: publicProcedure.query(() => {\n    return {\n      status: \"ok\",\n      timestamp: new Date().toISOString(),\n      version: \"0.1.0\",\n    };\n  }),\n\n  /**\n   * Example protected endpoint - get current user info\n   */\n  me: protectedProcedure.query(({ ctx }) => {\n    return {\n      user: ctx.user,\n      session: {\n        id: ctx.session.id,\n        expiresAt: ctx.session.expiresAt,\n      },\n    };\n  }),\n});\n\nexport type AppRouter = typeof appRouter;\n\nexport { createTRPCRouter, publicProcedure, protectedProcedure } from \"./init\";\nexport type { TRPCContext } from \"./init\";\n","import { fetchRequestHandler } from \"@trpc/server/adapters/fetch\";\nimport { appRouter, type TRPCContext } from \"./index\";\nimport { getSession } from \"../auth\";\nimport type { Session, User } from \"../db/schema\";\n\n/**\n * Creates the context for each tRPC request\n * Extracts session and user from the request using better-auth\n */\nexport const createContext = async (req: Request): Promise<TRPCContext> => {\n  let session: Session | null = null;\n  let user: User | null = null;\n\n  try {\n    const authSession = await getSession(req);\n\n    if (authSession?.session && authSession?.user) {\n      session = {\n        id: authSession.session.id,\n        token: authSession.session.token,\n        expiresAt: authSession.session.expiresAt,\n        createdAt: authSession.session.createdAt,\n        updatedAt: authSession.session.updatedAt,\n        ipAddress: authSession.session.ipAddress ?? null,\n        userAgent: authSession.session.userAgent ?? null,\n        userId: authSession.session.userId,\n      };\n\n      user = {\n        id: authSession.user.id,\n        name: authSession.user.name,\n        email: authSession.user.email,\n        emailVerified: authSession.user.emailVerified,\n        image: authSession.user.image ?? null,\n        createdAt: authSession.user.createdAt,\n        updatedAt: authSession.user.updatedAt,\n      };\n    }\n  } catch (error) {\n    // Session not found or invalid, continue as unauthenticated\n    console.debug(\"No valid session found:\", error);\n  }\n\n  return {\n    session,\n    user,\n    req,\n  };\n};\n\n/**\n * Handle tRPC requests using the fetch adapter\n */\nexport const handleTRPCRequest = async (req: Request): Promise<Response> => {\n  return fetchRequestHandler({\n    endpoint: \"/admin/api/trpc\",\n    req,\n    router: appRouter,\n    createContext: () => createContext(req),\n    onError: ({ path, error }) => {\n      console.error(`[tRPC Error] ${path}:`, error);\n    },\n  });\n};\n","import type { CreateCMSOptions, CMSHandlers } from \"./index\";\nimport { runGetRouter } from \"./get-router\";\nimport { createDatabase, type DrizzleClient } from \"./db\";\nimport { initStorage } from \"./storage\";\nimport { createAuth, getAuth } from \"./auth\";\nimport { handleTRPCRequest } from \"./trpc/handler\";\n\ntype ResolvedCMSOptions = {\n  basePath: string;\n  database: boolean;\n  storage: boolean;\n  auth: boolean;\n};\n\nconst defaultOptions: ResolvedCMSOptions = {\n  basePath: \"/admin\",\n  database: false,\n  storage: false,\n  auth: false,\n};\n\n/**\n * Creates a CMS instance with GET and POST handlers\n * Uses Web Standard Request/Response - works with any framework\n */\nexport const createCMS = (options?: CreateCMSOptions): CMSHandlers => {\n  const opts: ResolvedCMSOptions = {\n    ...defaultOptions,\n    basePath: options?.basePath ?? defaultOptions.basePath,\n    database: !!options?.database,\n    storage: !!options?.storage,\n    auth: !!options?.auth,\n  };\n\n  // Track initialization state\n  let initPromise: Promise<DrizzleClient | null> | null = null;\n  let initialized = false;\n\n  // Lazy initialization function\n  const ensureInitialized = async (): Promise<void> => {\n    if (initialized) return;\n\n    if (!initPromise) {\n      initPromise = (async () => {\n        // Initialize database if config provided (async for migrations)\n        let db: DrizzleClient | null = null;\n        if (options?.database) {\n          db = await createDatabase(options.database);\n        }\n\n        // Initialize storage if config provided\n        if (options?.storage) {\n          initStorage(options.storage);\n        }\n\n        // Initialize auth if config provided (requires database)\n        if (options?.auth && db) {\n          createAuth(db, {\n            ...options.auth,\n            authBasePath: `${opts.basePath}/api/auth`,\n          });\n        }\n\n        initialized = true;\n        return db;\n      })();\n    }\n\n    await initPromise;\n  };\n\n  const GET = async (req: Request): Promise<Response> => {\n    // Ensure CMS is initialized before handling requests\n    await ensureInitialized();\n\n    const url = new URL(req.url);\n    const { pathname } = url;\n\n    // Handle auth routes (under /admin/api/auth)\n    if (options?.auth && pathname.startsWith(`${opts.basePath}/api/auth`)) {\n      const auth = getAuth();\n      return auth.handler(req);\n    }\n\n    // Handle tRPC routes (under /admin/api/trpc)\n    if (pathname.startsWith(`${opts.basePath}/api/trpc`)) {\n      return handleTRPCRequest(req);\n    }\n\n    const isAdmin = pathname.startsWith(opts.basePath);\n    if (!isAdmin) {\n      return Response.json({\n        message:\n          \"Please put your CMS in the /admin route. Or customize basePath in the options.\",\n      });\n    }\n\n    return await runGetRouter(req, opts);\n  };\n\n  const POST = async (req: Request): Promise<Response> => {\n    // Ensure CMS is initialized before handling requests\n    await ensureInitialized();\n\n    const url = new URL(req.url);\n    const { pathname } = url;\n\n    // Handle auth routes (under /admin/api/auth)\n    if (options?.auth && pathname.startsWith(`${opts.basePath}/api/auth`)) {\n      const auth = getAuth();\n      return auth.handler(req);\n    }\n\n    // Handle tRPC routes (under /admin/api/trpc)\n    if (pathname.startsWith(`${opts.basePath}/api/trpc`)) {\n      return handleTRPCRequest(req);\n    }\n\n    const isAdmin = pathname.startsWith(opts.basePath);\n    if (!isAdmin) {\n      return Response.json({\n        message:\n          \"Please put your CMS in the /admin route. Or customize basePath in the options.\",\n      });\n    }\n\n    let body: unknown = null;\n    try {\n      body = await req.json();\n    } catch {\n      // Body might not be JSON\n    }\n\n    return Response.json({\n      message: \"Hello from CMS\",\n      method: req.method,\n      pathname,\n      query: url.searchParams.toString(),\n      body,\n      headers: Object.fromEntries(req.headers.entries()),\n    });\n  };\n\n  return { GET, POST };\n};\n"],"mappings":";;;;;;;;;;;;;;;;;AAAA,MAAa,gBAAgB,EAC3B,OACA,WAIY;;;;WAIH,MAAM;;;;;;;;;;;;;;;;IAgBb,KAAK;;;;;;ACxBT,MAAa,yBAAiC;AAC5C,QAAO,aAAa;EAClB,OAAO;EACP,MAAM;;;;EAIP,CAAC;;;;;;;;ACEJ,MAAa,eAAe,OAC1B,KACA,SACsB;CAEtB,MAAM,EAAE,aADI,IAAI,IAAI,IAAI,IAAI;CAE5B,MAAM,aAAa,SAAS,MAAM,KAAK,SAAS,CAAC,MAAM;AAGvD,KAAI,WAAW,WAAW,WAAW,EAAE;EACrC,MAAM,aAAa,WAAW,QAAQ,YAAY,GAAG;EAGrD,IAAIA,gBAAc;AAClB,MAAI,WAAW,SAAS,MAAM,CAC5B,iBAAc;WACL,WAAW,SAAS,OAAO,CACpC,iBAAc;WACL,WAAW,SAAS,QAAQ,CACrC,iBAAc;AAGhB,MAAI;GAEF,MAAM,gBAAgB;IAEpB,KACE,QAAQ,KAAK,EACb,gBACA,eACA,OACA,UACA,WACD;IAED,KACE,QAAQ,KAAK,EACb,MACA,MACA,YACA,OACA,UACA,WACD;IAED,KAAK,QAAQ,KAAK,EAAE,YAAY,OAAO,UAAU,WAAW;IAC7D;GAED,IAAIC,OAAsB;AAC1B,QAAK,MAAM,YAAY,cACrB,KAAI;AACF,WAAO,MAAM,SAAS,UAAU,QAAQ;AACxC;WACM;AAKV,OAAI,CAAC,KACH,OAAM,IAAI,MAAM,iBAAiB;AAGnC,UAAO,IAAI,SAAS,MAAM,EACxB,SAAS;IACP,gBAAgBD;IAChB,iBAAiB;IAClB,EACF,CAAC;UACI;AACN,UAAO,IAAI,SAAS,aAAa;IAC/B,QAAQ;IACR,SAAS;KACP,gBAAgB;KAChB,iBAAiB;KAClB;IACF,CAAC;;;AAKN,QAAO,IAAI,SAAS,kBAAkB,EAAE,EACtC,SAAS;EACP,gBAAgB;EAChB,iBAAiB;EAClB,EACF,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;ACzEJ,MAAa,eAAe;CAAC;CAAc;CAAS;CAAS;AAG7D,MAAa,OAAO,QAClB,YACA;CACE,IAAI,KAAK,KAAK,CAAC,YAAY;CAC3B,MAAM,KAAK,OAAO,CAAC,SAAS;CAC5B,OAAO,KAAK,QAAQ,CAAC,SAAS,CAAC,QAAQ;CACvC,eAAe,QAAQ,iBAAiB,CAAC,SAAS,CAAC,QAAQ,MAAM;CACjE,OAAO,KAAK,QAAQ;CACpB,MAAM,KAAK,QAAQ,EAAE,MAAM,cAAc,CAAC,CAAC,SAAS,CAAC,QAAQ,SAAS;CACtE,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CAC1D,GACA,UAAU,CAET,YAAY,6BAA6B,CACtC,GAAG,MAAM,KAAK,CACd,MAAM,GAAG,GAAG,MAAM,KAAK,iBAAiB,CAC5C,CACF;AAED,MAAa,UAAU,QAAQ,eAAe;CAC5C,IAAI,KAAK,KAAK,CAAC,YAAY;CAC3B,WAAW,UAAU,aAAa,CAAC,SAAS;CAC5C,OAAO,KAAK,QAAQ,CAAC,SAAS,CAAC,QAAQ;CACvC,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,KAAK,aAAa;CAC7B,WAAW,KAAK,aAAa;CAC7B,QAAQ,KAAK,UAAU,CACpB,SAAS,CACT,iBAAiB,KAAK,IAAI,EAAE,UAAU,WAAW,CAAC;CACtD,CAAC;AAEF,MAAa,UAAU,QAAQ,eAAe;CAC5C,IAAI,KAAK,KAAK,CAAC,YAAY;CAC3B,WAAW,KAAK,aAAa,CAAC,SAAS;CACvC,YAAY,KAAK,cAAc,CAAC,SAAS;CACzC,QAAQ,KAAK,UAAU,CACpB,SAAS,CACT,iBAAiB,KAAK,IAAI,EAAE,UAAU,WAAW,CAAC;CACrD,aAAa,KAAK,eAAe;CACjC,cAAc,KAAK,gBAAgB;CACnC,SAAS,KAAK,WAAW;CACzB,sBAAsB,UAAU,0BAA0B;CAC1D,uBAAuB,UAAU,2BAA2B;CAC5D,OAAO,KAAK,QAAQ;CACpB,UAAU,KAAK,WAAW;CAC1B,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CAC1D,CAAC;AAEF,MAAa,eAAe,QAAQ,oBAAoB;CACtD,IAAI,KAAK,KAAK,CAAC,YAAY;CAC3B,YAAY,KAAK,aAAa,CAAC,SAAS;CACxC,OAAO,KAAK,QAAQ,CAAC,SAAS;CAC9B,WAAW,UAAU,aAAa,CAAC,SAAS;CAC5C,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CAC1D,CAAC;;;;;AAUF,MAAa,cAAc,QAAQ,oBAAoB;CACrD,IAAI,KAAK,KAAK,CAAC,YAAY,CAAC,eAAe;CAC3C,MAAM,KAAK,OAAO,CAAC,SAAS,CAAC,QAAQ;CACrC,MAAM,KAAK,OAAO,CAAC,SAAS,CAAC,QAAQ;CACrC,aAAa,KAAK,cAAc;CAEhC,QAAQ,MAAM,SAAS,CAAC,SAAS,CAAC,OAA0B;CAC5D,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,aAAa,KAAK,gBAAgB,CAAC,iBAAiB,KAAK,GAAG;CAC7D,CAAC;;;;AAKF,MAAa,eAAe,QAAQ,qBAAqB;CACvD,IAAI,KAAK,KAAK,CAAC,YAAY,CAAC,eAAe;CAC3C,eAAe,KAAK,kBAAkB,CACnC,SAAS,CACT,iBAAiB,YAAY,IAAI,EAAE,UAAU,WAAW,CAAC;CAE5D,MAAM,MAAM,OAAO,CAAC,SAAS,CAAC,OAAgC;CAC9D,QAAQ,KAAK,UAAU,EAAE,MAAM;EAAC;EAAS;EAAa;EAAW,EAAE,CAAC,CACjE,SAAS,CACT,QAAQ,QAAQ;CACnB,aAAa,UAAU,eAAe;CACtC,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,aAAa,KAAK,gBAAgB,CAAC,iBAAiB,KAAK,GAAG;CAC5D,aAAa,KAAK,gBAAgB,CAAC,iBAAiB,KAAK,GAAG;CAC7D,CAAC;;;;AAKF,MAAa,QAAQ,QAAQ,aAAa;CACxC,IAAI,KAAK,KAAK,CAAC,YAAY,CAAC,eAAe;CAC3C,UAAU,KAAK,WAAW,CAAC,SAAS;CACpC,kBAAkB,KAAK,oBAAoB,CAAC,SAAS;CACrD,UAAU,KAAK,YAAY,CAAC,SAAS;CACrC,MAAM,QAAQ,OAAO,CAAC,SAAS;CAC/B,KAAK,KAAK,MAAM,CAAC,SAAS;CAC1B,YAAY,KAAK,cAAc,CAAC,SAAS;CACzC,KAAK,KAAK,MAAM;CAChB,SAAS,KAAK,UAAU;CACxB,UAAU,MAAM,WAAW,CAAC,OAAgC;CAC5D,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,WAAW,UAAU,aAAa,CAAC,SAAS,CAAC,YAAY;CACzD,cAAc,KAAK,iBAAiB,CAAC,iBAAiB,KAAK,GAAG;CAC/D,CAAC;;;;;AAUF,MAAa,gBAAgB;CAAC;CAAU;CAAU;CAAU;;;;AAM5D,MAAa,wBAAwB,EAAE,OAAO;CAE5C,IAAI,EAAE,QAAQ;CAEd,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE;CAEvB,KAAK,EACF,QAAQ,CACR,IAAI,EAAE,CACN,MAAM,uBAAuB,oBAAoB;CAEpD,MAAM,EAAE,KAAK,cAAc;CAE3B,UAAU,EAAE,SAAS,CAAC,QAAQ,MAAM;CAEpC,aAAa,EAAE,QAAQ,CAAC,UAAU;CAElC,cAAc,EAAE,MAAM;EAAC,EAAE,QAAQ;EAAE,EAAE,QAAQ;EAAE,EAAE,SAAS;EAAC,CAAC,CAAC,UAAU;CACxE,CAAC;;;;AAKF,MAAa,6BAA6B,EAAE,OAAO,EACjD,QAAQ,EAAE,MAAM,sBAAsB,EACvC,CAAC;;;;AAQF,MAAa,qBAAqB;;;;AC7JlC,IAAIE,aAAmC;AACvC,IAAI,eAAe;;;;;AAMnB,MAAM,0BAAkC;CACtC,MAAMC,gBAA0B,EAAE;AAGlC,KAAI;EAEF,MAAM,YAAY,QADC,cAAc,OAAO,KAAK,IAAI,CACZ;AAGrC,gBAAc,KAAK,KAAK,WAAW,MAAM,MAAM,UAAU,CAAC;AAG1D,gBAAc,KAAK,KAAK,WAAW,MAAM,MAAM,UAAU,CAAC;SACpD;AAKR,eAAc,KAAK,KAAK,QAAQ,KAAK,EAAE,YAAY,OAAO,UAAU,CAAC;AACrE,eAAc,KACZ,KAAK,QAAQ,KAAK,EAAE,MAAM,MAAM,YAAY,OAAO,UAAU,CAC9D;AAGD,eAAc,KACZ,KAAK,QAAQ,KAAK,EAAE,gBAAgB,eAAe,OAAO,UAAU,CACrE;AAGD,MAAK,MAAM,QAAQ,cAEjB,KAAI,WADgB,KAAK,MAAM,QAAQ,gBAAgB,CAC5B,EAAE;AAC3B,UAAQ,IAAI,8BAA8B,OAAO;AACjD,SAAO;;AAKX,SAAQ,MACN,kDACA,cACD;AAGD,QAAO,cAAc;;;;;;AAOvB,MAAa,gBAAgB,OAAO,OAAqC;AACvE,KAAI,aACF;AAGF,SAAQ,IAAI,uCAAuC;AAEnD,KAAI;AAGF,QAAM,QAAQ,IAAI,EAChB,kBAHuB,mBAAmB,EAI3C,CAAC;AAEF,iBAAe;AACf,UAAQ,IAAI,sCAAsC;UAC3C,OAAO;AACd,UAAQ,MAAM,0BAA0B,MAAM;AAC9C,QAAM;;;;;;AAOV,MAAa,iBAAiB,OAC5B,WAC2B;AAC3B,KAAI,WACF,QAAO;CAGT,IAAIC;CACJ,MAAM,cAAc,OAAO,eAAe;AAE1C,KAAI,sBAAsB,OACxB,oBAAmB,OAAO;MACrB;EACL,MAAM,EAAE,MAAM,OAAO,MAAM,cAAM,UAAU,UAAU,QAAQ;AAC7D,qBAAmB,gBAAgBC,OAAK,GAAG,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG,WACrE,MAAM,qBAAqB;;AAI/B,cAAa,QAAQ,kBAAkB,EAAE,wBAAQ,CAAC;AAGlD,KAAI,YACF,OAAM,cAAc,WAAW;AAGjC,QAAO;;;;;;AAOT,MAAa,oBAAmC;AAC9C,KAAI,CAAC,WACH,OAAM,IAAI,MACR,gGACD;AAEH,QAAO;;;;;AAMT,MAAa,eAAe,OAA4B;AACtD,cAAa;;;;;;;;;AC9Jf,MAAa,sBAAsB,EAAE,OAAO;CAK1C,UAAU,EAAE,KAAK;CAKjB,QAAQ,EAAE,QAAQ;CAKlB,aAAa,EAAE,QAAQ;CAKvB,iBAAiB,EAAE,QAAQ;CAK3B,QAAQ,EAAE,QAAQ,CAAC,UAAU,CAAC,QAAQ,OAAO;CAM7C,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,UAAU;CAMtC,YAAY,EAAE,QAAQ,CAAC,UAAU,CAAC,QAAQ,MAAM;CACjD,CAAC;AAIF,IAAIC,kBAAwC;;;;AAwC5C,MAAa,uBAAuB,WAAyC;CAC3E,MAAM,kBAAkB,oBAAoB,MAAM,OAAO;CAEzD,MAAM,gBAAgB,eAA+B;AACnD,MAAI,gBAAgB,UAClB,QAAO,GAAG,gBAAgB,UAAU,GAAG;AAEzC,SAAO,GAAG,gBAAgB,SAAS,GAAG,gBAAgB,OAAO,GAAG;;CAGlE,MAAM,gBAAgB,UAAkB,WAA4B;AAUlE,SAJc;GALC,gBAAgB;GAKR;GAAQ,GAJb,KAAK,KAAK,CAIgB,GAH3B,KAAK,QAAQ,CAAC,SAAS,GAAG,CAAC,UAAU,GAAG,EAAE,CAGH,GAFnC,SAAS,QAAQ,mBAAmB,IAAI;GAEa,CACvE,OAAO,QAAQ,CACf,KAAK,IAAI;;CAKd,MAAM,SAAS,OACb,MACA,YAK0B;EAC1B,MAAM,WACJ,SAAS,aAAa,gBAAgB,OAAO,KAAK,OAAO;EAC3D,MAAMC,gBACJ,SAAS,eAAe,KAAK,QAAQ;EACvC,MAAM,aAAa,aAAa,UAAU,SAAS,OAAO;EAG1D,MAAM,YAAY,GAAG,gBAAgB,SAAS,GAAG,gBAAgB,OAAO,GAAG;EAG3E,MAAM,cAAc,MAAM,KAAK,aAAa;EAK5C,MAAM,WAAW,MAAM,MAAM,WAAW;GACtC,QAAQ;GACR,SAAS;IACP,gBAAgBA;IAChB,kBAAkB,OAAO,YAAY,WAAW;IAGjD;GACD,MAAM;GACP,CAAC;AAEF,MAAI,CAAC,SAAS,GACZ,OAAM,IAAI,MACR,kBAAkB,SAAS,OAAO,GAAG,SAAS,aAC/C;AAGH,SAAO;GACL,KAAK,aAAa,WAAW;GAC7B;GACA;GACD;;CAGH,MAAM,aAAa,OAAO,eAAsC;EAC9D,MAAM,YAAY,GAAG,gBAAgB,SAAS,GAAG,gBAAgB,OAAO,GAAG;EAE3E,MAAM,WAAW,MAAM,MAAM,WAAW,EACtC,QAAQ,UAET,CAAC;AAEF,MAAI,CAAC,SAAS,MAAM,SAAS,WAAW,IACtC,OAAM,IAAI,MACR,kBAAkB,SAAS,OAAO,GAAG,SAAS,aAC/C;;CAIL,MAAM,eAAe,OACnB,YACA,aAAqB,SACD;AAIpB,SAAO,aAAa,WAAW;;AAGjC,QAAO;EACL;EACA,QAAQ;EACR;EACA;EACD;;;;;AAMH,MAAa,eAAe,WAAyC;AACnE,mBAAkB,oBAAoB,OAAO;AAC7C,QAAO;;;;;AAMT,MAAa,mBAAkC;AAC7C,KAAI,CAAC,gBACH,OAAM,IAAI,MACR,2FACD;AAEH,QAAO;;;;;AAMT,MAAa,cAAc,WAAgC;AACzD,mBAAkB;;;;;ACpKpB,IAAIC,eAAqD;;;;AAKzD,MAAa,cAAc,IAAmB,WAAuB;CACnE,MAAM,OAAO,WAAW;EACtB,UAAU,eAAe,IAAI;GAC3B,UAAU;GACV,QAAQ;IACAC;IACGC;IACAC;IACKC;IACf;GACF,CAAC;EACF,UAAU,OAAO,gBAAgB;EACjC,QAAQ,OAAO;EACf,SAAS,OAAO;EAChB,gBAAgB,OAAO;EACvB,kBAAkB,EAChB,SAAS,OAAO,oBAAoB,MACrC;EACD,iBAAiB;GACf,GAAI,OAAO,iBAAiB,UAAU,EACpC,QAAQ;IACN,UAAU,OAAO,gBAAgB,OAAO;IACxC,cAAc,OAAO,gBAAgB,OAAO;IAC7C,EACF;GACD,GAAI,OAAO,iBAAiB,UAAU,EACpC,QAAQ;IACN,UAAU,OAAO,gBAAgB,OAAO;IACxC,cAAc,OAAO,gBAAgB,OAAO;IAC7C,EACF;GACF;EACD,SAAS;GACP,WAAW,OAAU,KAAK;GAC1B,WAAW,OAAU;GACtB;EACF,CAAC;AAEF,gBAAe;AACf,QAAO;;;;;AAMT,MAAa,gBAAgB;AAC3B,KAAI,CAAC,aACH,OAAM,IAAI,MACR,oFACD;AAEH,QAAO;;;;;AAMT,MAAa,aAAa,OAAO,QAAiB;AAKhD,QAHgB,MADH,SAAS,CACK,IAAI,WAAW,EACxC,SAAS,IAAI,SACd,CAAC;;;;;AAOJ,MAAa,kBAAkB,OAAO,QAAmC;AACvE,KAAI;EACF,MAAMC,YAAU,MAAM,WAAW,IAAI;AACrC,SAAOA,cAAY,QAAQA,UAAQ,YAAY;SACzC;AACN,SAAO;;;;;;;;;ACjHX,MAAM,IAAI,SAAS,SAAsB,CAAC,OAAO;CAC/C,aAAa;CACb,eAAe,EAAE,OAAO,SAAS;AAC/B,SAAO;GACL,GAAG;GACH,MAAM;IACJ,GAAG,MAAM;IACT,UACE,MAAM,iBAAiB,QAAQ,MAAM,MAAM,UAAU;IACxD;GACF;;CAEJ,CAAC;;;;AAKF,MAAa,mBAAmB,EAAE;AAClC,MAAa,sBAAsB,EAAE;;;;;AAMrC,MAAa,kBAAkB,EAAE;;;;;AAMjC,MAAa,qBAAqB,EAAE,UAAU,KAAK,EAAE,KAAK,WAAW;AACnE,KAAI,CAAC,IAAI,WAAW,CAAC,IAAI,KACvB,OAAM,IAAI,UAAU;EAClB,MAAM;EACN,SAAS;EACV,CAAC;AAGJ,QAAO,KAAK,EACV,KAAK;EACH,GAAG;EAEH,SAAS,IAAI;EACb,MAAM,IAAI;EACX,EACF,CAAC;EACF;;;;AAKF,MAAa,mBAAmB,EAAE,WAAW,OAAO,EAAE,MAAM,MAAM,WAAW;CAC3E,MAAM,QAAQ,KAAK,KAAK;CACxB,MAAM,SAAS,MAAM,MAAM;CAC3B,MAAM,WAAW,KAAK,KAAK,GAAG;AAE9B,SAAQ,IAAI,UAAU,KAAK,GAAG,KAAK,KAAK,SAAS,IAAI;AAErD,QAAO;EACP;;;;ACjEF,MAAa,oBAAoB,iBAAiB;CAIhD,MAAM,gBAAgB,MAAM,YAAY;AAGtC,SADc,MADH,aAAa,CACD,QAAQ,CAAC,KAAK,YAAY,CAAC,QAAQ,YAAY,KAAK;GAE3E;CAKF,WAAW,gBACR,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC,CACrC,MAAM,OAAO,EAAE,YAAY;EAE1B,MAAM,CAAC,QAAQ,MADJ,aAAa,CAErB,QAAQ,CACR,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,MAAM,MAAM,KAAK,CAAC,CACvC,MAAM,EAAE;AAEX,SAAO,QAAQ;GACf;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EAChC,MAAM,EACH,QAAQ,CACR,IAAI,EAAE,CACN,IAAI,IAAI,CACR,MAAM,eAAe;EACxB,aAAa,EAAE,QAAQ,CAAC,UAAU;EAClC,QAAQ;EACT,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,WAAW,MAFP,aAAa,CAGrB,OAAO,YAAY,CACnB,OAAO;GACN,MAAM,MAAM;GACZ,MAAM,MAAM;GACZ,aAAa,MAAM;GACnB,QAAQ,MAAM;GACd,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU;EAC3C,aAAa,EAAE,QAAQ,CAAC,UAAU;EAClC,QAAQ,2BAA2B,UAAU;EAC9C,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAExB,MAAMC,aAAuD,EAC3D,2BAAW,IAAI,MAAM,EACtB;AAED,MAAI,MAAM,KAAM,YAAW,OAAO,MAAM;AACxC,MAAI,MAAM,gBAAgB,OACxB,YAAW,cAAc,MAAM;AACjC,MAAI,MAAM,OAAQ,YAAW,SAAS,MAAM;EAE5C,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,YAAY,CACnB,IAAI,WAAW,CACf,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC,CACnC,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,YAAY;AAG7B,QAFW,aAAa,CAEf,OAAO,YAAY,CAAC,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC;AAEhE,SAAO,EAAE,SAAS,MAAM;GACxB;CACL,CAAC;;;;AC5GF,MAAa,qBAAqB,iBAAiB;CAIjD,MAAM,gBACH,MACC,EAAE,OAAO;EACP,iBAAiB,EAAE,QAAQ;EAC3B,QAAQ,EAAE,KAAK;GAAC;GAAS;GAAa;GAAW,CAAC,CAAC,UAAU;EAC7D,OAAO,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,GAAG;EACxD,QAAQ,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,EAAE;EAChD,CAAC,CACH,CACA,MAAM,OAAO,EAAE,YAAY;EAC1B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,QAAQ,MAAM,GAClB,QAAQ,CACR,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,MAAM,MAAM,gBAAgB,CAAC,CAClD,MAAM,EAAE;AAEX,MAAI,CAAC,KACH,QAAO;GAAE,SAAS,EAAE;GAAE,OAAO;GAAG;EAGlC,MAAM,aAAa,CAAC,GAAG,aAAa,eAAe,KAAK,GAAG,CAAC;AAE5D,MAAI,MAAM,OACR,YAAW,KAAK,GAAG,aAAa,QAAQ,MAAM,OAAO,CAAC;EAGxD,MAAM,UAAU,MAAM,GACnB,QAAQ,CACR,KAAK,aAAa,CAClB,MAAM,IAAI,GAAG,WAAW,CAAC,CACzB,QAAQ,KAAK,aAAa,UAAU,CAAC,CACrC,MAAM,MAAM,MAAM,CAClB,OAAO,MAAM,OAAO;AAEvB,SAAO;GAAE;GAAS,OAAO,QAAQ;GAAQ;GACzC;CAKJ,SAAS,gBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,SAAS,MAFL,aAAa,CAGrB,QAAQ,CACR,KAAK,aAAa,CAClB,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,MAAM,EAAE;AAEX,SAAO,SAAS;GAChB;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,eAAe,EAAE,QAAQ,CAAC,MAAM;EAChC,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC;EACvC,QAAQ,EACL,KAAK;GAAC;GAAS;GAAa;GAAW,CAAC,CACxC,UAAU,CACV,QAAQ,QAAQ;EACpB,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,YAAY,MAFR,aAAa,CAGrB,OAAO,aAAa,CACpB,OAAO;GACN,eAAe,MAAM;GACrB,MAAM,MAAM;GACZ,QAAQ,MAAM;GACd,aAAa,MAAM,WAAW,8BAAc,IAAI,MAAM,GAAG;GACzD,aAAa,IAAI,KAAK;GACtB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC,CAAC,UAAU;EAClD,QAAQ,EAAE,KAAK;GAAC;GAAS;GAAa;GAAW,CAAC,CAAC,UAAU;EAC9D,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAClC,MAAM,KAAK,aAAa;EAExB,MAAMC,aAAwD;GAC5D,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB;AAED,MAAI,MAAM,KAAM,YAAW,OAAO,MAAM;AACxC,MAAI,MAAM,QAAQ;AAChB,cAAW,SAAS,MAAM;AAC1B,OAAI,MAAM,WAAW,YACnB,YAAW,8BAAc,IAAI,MAAM;;EAIvC,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,aAAa,CACpB,IAAI,WAAW,CACf,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,YAAY;AAG7B,QAFW,aAAa,CAEf,OAAO,aAAa,CAAC,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC;AAElE,SAAO,EAAE,SAAS,MAAM;GACxB;CAKJ,SAAS,mBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,WAAW,MAFP,aAAa,CAGrB,OAAO,aAAa,CACpB,IAAI;GACH,QAAQ;GACR,6BAAa,IAAI,MAAM;GACvB,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,SAAO;GACP;CAKJ,WAAW,mBACR,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,WAAW,MAFP,aAAa,CAGrB,OAAO,aAAa,CACpB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,SAAO;GACP;CACL,CAAC;;;;ACvLF,MAAa,cAAc,iBAAiB;CAI1C,MAAM,gBACH,MACC,EAAE,OAAO;EACP,OAAO,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,GAAG;EACxD,QAAQ,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,UAAU,CAAC,QAAQ,EAAE;EAC/C,UAAU,EAAE,QAAQ,CAAC,UAAU;EAChC,CAAC,CACH,CACA,MAAM,OAAO,EAAE,YAAY;EAG1B,IAAI,QAFO,aAAa,CAGrB,QAAQ,CACR,KAAK,MAAM,CACX,QAAQ,KAAK,MAAM,UAAU,CAAC,CAC9B,MAAM,MAAM,MAAM,CAClB,OAAO,MAAM,OAAO;AAEvB,MAAI,MAAM,SACR,SAAQ,MAAM,MAAM,GAAG,MAAM,UAAU,MAAM,SAAS,CAAC;EAGzD,MAAM,QAAQ,MAAM;AAEpB,SAAO;GAAE;GAAO,OAAO,MAAM;GAAQ;GACrC;CAKJ,SAAS,gBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,QAAQ,MAFJ,aAAa,CAGrB,QAAQ,CACR,KAAK,MAAM,CACX,MAAM,GAAG,MAAM,IAAI,MAAM,GAAG,CAAC,CAC7B,MAAM,EAAE;AAEX,SAAO,QAAQ;GACf;CAOJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,UAAU,EAAE,QAAQ;EACpB,kBAAkB,EAAE,QAAQ;EAC5B,UAAU,EAAE,QAAQ;EACpB,MAAM,EAAE,QAAQ;EAChB,KAAK,EAAE,QAAQ,CAAC,KAAK;EACrB,YAAY,EAAE,QAAQ;EACtB,KAAK,EAAE,QAAQ,CAAC,UAAU;EAC1B,SAAS,EAAE,QAAQ,CAAC,UAAU;EAC9B,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC,CAAC,UAAU;EACvD,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,YAAY,MAFR,aAAa,CAGrB,OAAO,MAAM,CACb,OAAO;GACN,UAAU,MAAM;GAChB,kBAAkB,MAAM;GACxB,UAAU,MAAM;GAChB,MAAM,MAAM;GACZ,KAAK,MAAM;GACX,YAAY,MAAM;GAClB,KAAK,MAAM;GACX,SAAS,MAAM;GACf,UAAU,MAAM;GAChB,cAAc,IAAI,KAAK;GACxB,CAAC,CACD,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,KAAK,EAAE,QAAQ,CAAC,UAAU;EAC1B,SAAS,EAAE,QAAQ,CAAC,UAAU;EAC9B,UAAU,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC,CAAC,UAAU;EACvD,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAExB,MAAMC,aAAiD,EACrD,2BAAW,IAAI,MAAM,EACtB;AAED,MAAI,MAAM,QAAQ,OAAW,YAAW,MAAM,MAAM;AACpD,MAAI,MAAM,YAAY,OAAW,YAAW,UAAU,MAAM;AAC5D,MAAI,MAAM,SAAU,YAAW,WAAW,MAAM;EAEhD,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,MAAM,CACb,IAAI,WAAW,CACf,MAAM,GAAG,MAAM,IAAI,MAAM,GAAG,CAAC,CAC7B,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,eAAe,MAAM,GACzB,QAAQ,CACR,KAAK,MAAM,CACX,MAAM,GAAG,MAAM,IAAI,MAAM,GAAG,CAAC,CAC7B,MAAM,EAAE;AAEX,MAAI,CAAC,YACH,QAAO;GAAE,SAAS;GAAO,OAAO;GAAmB;AAIrD,MAAI;AAEF,SADgB,YAAY,CACd,OAAO,YAAY,WAAW;WACrC,OAAO;AACd,WAAQ,MAAM,uCAAuC,MAAM;;AAK7D,QAAM,GAAG,OAAO,MAAM,CAAC,MAAM,GAAG,MAAM,IAAI,MAAM,GAAG,CAAC;AAEpD,SAAO,EAAE,SAAS,MAAM;GACxB;CAKJ,cAAc,mBACX,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,WAAW,EAAE,QAAQ,CAAC,UAAU,CAAC,QAAQ,KAAK;EAC/C,CAAC,CACH,CACA,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,eAAe,MAFX,aAAa,CAGrB,QAAQ,CACR,KAAK,MAAM,CACX,MAAM,GAAG,MAAM,IAAI,MAAM,GAAG,CAAC,CAC7B,MAAM,EAAE;AAEX,MAAI,CAAC,YACH,QAAO;AAST,SAAO,EAAE,KALS,MADF,YAAY,CACI,aAC9B,YAAY,YACZ,MAAM,UACP,EAEwB;GACzB;CACL,CAAC;;;;AC1LF,MAAa,cAAc,iBAAiB;CAK1C,WAAW,gBAAgB,MAAM,YAAY;AAC3C,MAAI;GAIF,MAAM,CAAC,cAAc,MAHV,aAAa,CAIrB,OAAO,EAAE,IAAI,KAAK,IAAI,CAAC,CACvB,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,MAAM,aAAa,CAAC,CAClC,MAAM,EAAE;AAEX,UAAO;IACL,iBAAiB,CAAC,CAAC;IACnB,eAAe,CAAC,CAAC;IAClB;WACM,OAAO;AAEd,WAAQ,MAAM,8BAA8B,MAAM;AAClD,UAAO;IACL,iBAAiB;IACjB,eAAe;IACf,OAAO;IACR;;GAEH;CAOF,kBAAkB,gBACf,MACC,EAAE,OAAO;EACP,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EAChC,OAAO,EAAE,QAAQ,CAAC,OAAO;EACzB,UAAU,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EACrC,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,sBAAsB,MAAM,GAChC,OAAO,EAAE,IAAI,KAAK,IAAI,CAAC,CACvB,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,MAAM,aAAa,CAAC,CAClC,MAAM,EAAE;AAEX,MAAI,mBACF,OAAM,IAAI,MAAM,uDAAuD;EAOzE,MAAM,eAAe,MAHR,SAAS,CAGU,IAAI,YAAY,EAC9C,MAAM;GACJ,MAAM,MAAM;GACZ,OAAO,MAAM;GACb,UAAU,MAAM;GACjB,EACF,CAAC;AAEF,MAAI,CAAC,gBAAgB,CAAC,aAAa,KACjC,OAAM,IAAI,MAAM,gCAAgC;AAKlD,MAAI;AACF,SAAM,GACH,OAAO,KAAK,CACZ,IAAI;IACH,MAAM;IACN,2BAAW,IAAI,MAAM;IACtB,CAAC,CACD,MAAM,GAAG,KAAK,IAAI,aAAa,KAAK,GAAG,CAAC;WACpC,OAAO;AAGd,SAAM,GAAG,OAAO,KAAK,CAAC,MAAM,GAAG,KAAK,IAAI,aAAa,KAAK,GAAG,CAAC;AAC9D,SAAM,IAAI,MAAM,uDAAuD;;AAGzE,SAAO;GACL,SAAS;GACT,SAAS;GACT,MAAM;IACJ,IAAI,aAAa,KAAK;IACtB,MAAM,aAAa,KAAK;IACxB,OAAO,aAAa,KAAK;IAC1B;GACF;GACD;CAKJ,WAAW,mBAAmB,MAAM,OAAO,EAAE,UAAU;EAGrD,MAAM,CAAC,YAAY,MAFR,aAAa,CAGrB,OAAO,EAAE,MAAM,KAAK,MAAM,CAAC,CAC3B,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,CAC/B,MAAM,EAAE;AAEX,SAAO;GACL,MAAM,UAAU,QAAQ;GACxB,cAAc,UAAU,SAAS;GACjC,SAAS,UAAU,SAAS,WAAW,UAAU,SAAS;GAC3D;GACD;CAKF,aAAa,mBACV,MACC,EAAE,OAAO;EACP,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EAChC,OAAO,EAAE,QAAQ,CAAC,OAAO;EACzB,UAAU,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EACpC,MAAM,EAAE,KAAK,CAAC,SAAS,SAAS,CAAC;EAClC,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAClC,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,eAAe,MAAM,GACzB,OAAO,EAAE,MAAM,KAAK,MAAM,CAAC,CAC3B,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,CAC/B,MAAM,EAAE;AAEX,MAAI,aAAa,SAAS,aACxB,OAAM,IAAI,MAAM,yCAAyC;EAI3D,MAAM,CAAC,gBAAgB,MAAM,GAC1B,OAAO,EAAE,IAAI,KAAK,IAAI,CAAC,CACvB,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,OAAO,MAAM,MAAM,CAAC,CAClC,MAAM,EAAE;AAEX,MAAI,aACF,OAAM,IAAI,MAAM,wCAAwC;EAM1D,MAAM,eAAe,MAFR,SAAS,CAEU,IAAI,YAAY,EAC9C,MAAM;GACJ,MAAM,MAAM;GACZ,OAAO,MAAM;GACb,UAAU,MAAM;GACjB,EACF,CAAC;AAEF,MAAI,CAAC,gBAAgB,CAAC,aAAa,KACjC,OAAM,IAAI,MAAM,gCAAgC;AAIlD,QAAM,GACH,OAAO,KAAK,CACZ,IAAI;GACH,MAAM,MAAM;GACZ,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,KAAK,IAAI,aAAa,KAAK,GAAG,CAAC;AAE3C,SAAO;GACL,SAAS;GACT,MAAM;IACJ,IAAI,aAAa,KAAK;IACtB,MAAM,aAAa,KAAK;IACxB,OAAO,aAAa,KAAK;IACzB,MAAM,MAAM;IACb;GACF;GACD;CAKJ,YAAY,mBAAmB,MAAM,OAAO,EAAE,UAAU;EACtD,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,eAAe,MAAM,GACzB,OAAO,EAAE,MAAM,KAAK,MAAM,CAAC,CAC3B,KAAK,KAAK,CACV,MAAM,GAAG,KAAK,IAAI,IAAI,KAAK,GAAG,CAAC,CAC/B,MAAM,EAAE;AAEX,MAAI,aAAa,SAAS,aACxB,OAAM,IAAI,MAAM,uCAAuC;AAczD,SAAO,EAAE,QAXM,MAAM,GAClB,OAAO;GACN,IAAI,KAAK;GACT,MAAM,KAAK;GACX,OAAO,KAAK;GACZ,MAAM,KAAK;GACX,WAAW,KAAK;GACjB,CAAC,CACD,KAAK,KAAK,CACV,QAAQ,KAAK,UAAU,EAET;GACjB;CACH,CAAC;;;;;;;ACxNF,SAAS,aAAa,MAAsB;AAC1C,QAAO,KACJ,aAAa,CACb,QAAQ,eAAe,IAAI,CAC3B,QAAQ,UAAU,GAAG;;;;;AAM1B,SAAS,kBAA0B;AACjC,QAAO,SAAS,KAAK,KAAK,CAAC,GAAG,KAAK,QAAQ,CAAC,SAAS,GAAG,CAAC,OAAO,GAAG,EAAE;;AAGvE,MAAa,oBAAoB,iBAAiB;CAIhD,MAAM,mBAAmB,MAAM,YAAY;AAgBzC,SAboB,MAFT,aAAa,CAGrB,OAAO;GACN,IAAI,YAAY;GAChB,MAAM,YAAY;GAClB,MAAM,YAAY;GAClB,aAAa,YAAY;GACzB,QAAQ,YAAY;GACpB,WAAW,YAAY;GACvB,WAAW,YAAY;GACxB,CAAC,CACD,KAAK,YAAY,CACjB,QAAQ,YAAY,KAAK;GAG5B;CAKF,SAAS,mBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,cAAc,MAFV,aAAa,CAGrB,QAAQ,CACR,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC,CACnC,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;AAGzC,SAAO;GACP;CAKJ,WAAW,mBACR,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAC,CAAC,CACrC,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,cAAc,MAFV,aAAa,CAGrB,QAAQ,CACR,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,MAAM,MAAM,KAAK,CAAC,CACvC,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;AAGzC,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI;EAChC,aAAa,EAAE,QAAQ,CAAC,UAAU;EACnC,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAClC,MAAM,KAAK,aAAa;EAExB,MAAM,OAAO,aAAa,MAAM,KAAK;EAGrC,MAAM,CAAC,YAAY,MAAM,GACtB,OAAO,EAAE,IAAI,YAAY,IAAI,CAAC,CAC9B,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,MAAM,KAAK,CAAC,CACjC,MAAM,EAAE;AAEX,MAAI,SACF,OAAM,IAAI,MAAM,+BAA+B,KAAK,kBAAkB;EAMxE,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,YAAY,CACnB,OAAO;GACN,MAAM,MAAM;GACZ;GACA,aAAa,MAAM;GACnB,QAR8B,EAAE,QAAQ,EAAE,EAAE;GAS5C,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,MAAM,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,UAAU;EAC3C,aAAa,EAAE,QAAQ,CAAC,UAAU;EACnC,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAExB,MAAMC,UAAoD,EACxD,2BAAW,IAAI,MAAM,EACtB;AAED,MAAI,MAAM,MAAM;AACd,WAAQ,OAAO,MAAM;AACrB,WAAQ,OAAO,aAAa,MAAM,KAAK;GAGvC,MAAM,CAAC,YAAY,MAAM,GACtB,OAAO,EAAE,IAAI,YAAY,IAAI,CAAC,CAC9B,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,MAAM,QAAQ,KAAK,CAAC,CACzC,MAAM,EAAE;AAEX,OAAI,YAAY,SAAS,OAAO,MAAM,GACpC,OAAM,IAAI,MACR,+BAA+B,QAAQ,KAAK,kBAC7C;;AAIL,MAAI,MAAM,gBAAgB,OACxB,SAAQ,cAAc,MAAM;EAG9B,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,YAAY,CACnB,IAAI,QAAQ,CACZ,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC,CACnC,WAAW;AAEd,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;AAGzC,SAAO;GACP;CAKJ,QAAQ,mBACL,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,YAAY;EAG7B,MAAM,CAAC,WAAW,MAFP,aAAa,CAGrB,OAAO,YAAY,CACnB,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC,CACnC,UAAU,EAAE,IAAI,YAAY,IAAI,CAAC;AAEpC,MAAI,CAAC,QACH,OAAM,IAAI,MAAM,uBAAuB;AAGzC,SAAO,EAAE,SAAS,MAAM;GACxB;CAKJ,cAAc,mBACX,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,QAAQ;EACT,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,OAAO,MAAM,OAAO,OAAO,KAAK,MAAM,EAAE,IAAI;AAClD,MAAI,IAAI,IAAI,KAAK,CAAC,SAAS,KAAK,OAC9B,OAAM,IAAI,MAAM,4BAA4B;EAG9C,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,YAAY,CACnB,IAAI;GACH,QAAQ,MAAM;GACd,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,YAAY,IAAI,MAAM,GAAG,CAAC,CACnC,WAAW;AAEd,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;AAGzC,SAAO;GACP;CAKJ,UAAU,mBACP,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,OAAO,sBAAsB,KAAK,EAAE,IAAI,MAAM,CAAC;EAChD,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,EAAE,QAAQ,YAAY,QAAQ,CAAC,CACtC,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;EAGzC,MAAM,gBAAgB,WAAW;AAGjC,MAAI,cAAc,OAAO,MAAM,MAAM,EAAE,QAAQ,MAAM,MAAM,IAAI,CAC7D,OAAM,IAAI,MAAM,qBAAqB,MAAM,MAAM,IAAI,kBAAkB;EAIzE,MAAM,WAAW;GACf,GAAG,MAAM;GACT,IAAI,iBAAiB;GACtB;EAED,MAAMC,gBAAmC,EACvC,QAAQ,CAAC,GAAG,cAAc,QAAQ,SAAS,EAC5C;EAED,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,YAAY,CACnB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,WAAW;AAEd,SAAO;GACP;CAKJ,aAAa,mBACV,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,SAAS,EAAE,QAAQ;EACnB,SAAS,sBAAsB,SAAS,CAAC,KAAK,EAAE,IAAI,MAAM,CAAC;EAC5D,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,EAAE,QAAQ,YAAY,QAAQ,CAAC,CACtC,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;EAGzC,MAAM,gBAAgB,WAAW;EAGjC,MAAM,aAAa,cAAc,OAAO,WACrC,MAAM,EAAE,OAAO,MAAM,QACvB;AAED,MAAI,eAAe,GACjB,OAAM,IAAI,MAAM,kBAAkB;AAIpC,MACE,MAAM,QAAQ,OACd,cAAc,OAAO,MAClB,GAAG,MAAM,MAAM,cAAc,EAAE,QAAQ,MAAM,QAAQ,IACvD,CAED,OAAM,IAAI,MACR,qBAAqB,MAAM,QAAQ,IAAI,kBACxC;EAGH,MAAM,gBAAgB,CAAC,GAAG,cAAc,OAAO;AAC/C,gBAAc,cAAc;GAC1B,GAAG,cAAc;GACjB,GAAG,MAAM;GACV;EAED,MAAMA,gBAAmC,EACvC,QAAQ,eACT;EAED,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,YAAY,CACnB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,WAAW;AAEd,SAAO;GACP;CAKJ,aAAa,mBACV,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,SAAS,EAAE,QAAQ;EACpB,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,EAAE,QAAQ,YAAY,QAAQ,CAAC,CACtC,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;EAKzC,MAAMA,gBAAmC,EACvC,QAHoB,WAAW,OAGT,OAAO,QAAQ,MAAM,EAAE,OAAO,MAAM,QAAQ,EACnE;EAED,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,YAAY,CACnB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,WAAW;AAEd,SAAO;GACP;CAKJ,eAAe,mBACZ,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,UAAU,EAAE,MAAM,EAAE,QAAQ,CAAC;EAC9B,CAAC,CACH,CACA,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,EAAE,QAAQ,YAAY,QAAQ,CAAC,CACtC,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;EAGzC,MAAM,gBAAgB,WAAW;EAGjC,MAAM,WAAW,IAAI,IAAI,cAAc,OAAO,KAAK,MAAM,CAAC,EAAE,IAAI,EAAE,CAAC,CAAC;EACpE,MAAM,kBAAkB,MAAM,SAC3B,KAAK,OAAO,SAAS,IAAI,GAAG,CAAC,CAC7B,QAAQ,MAAkC,MAAM,OAAU;AAG7D,OAAK,MAAM,SAAS,cAAc,OAChC,KAAI,CAAC,MAAM,SAAS,SAAS,MAAM,GAAG,CACpC,iBAAgB,KAAK,MAAM;EAI/B,MAAMA,gBAAmC,EACvC,QAAQ,iBACT;EAED,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,YAAY,CACnB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACtB,CAAC,CACD,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,WAAW;AAEd,SAAO;GACP;CACL,CAAC;;;;;;;ACjcF,SAAS,kBACP,MACA,QACsC;CACtC,MAAMC,SAAmB,EAAE;AAE3B,MAAK,MAAM,SAAS,OAAO,QAAQ;EACjC,MAAM,QAAQ,KAAK,MAAM;AAGzB,MACE,MAAM,aACL,UAAU,UAAa,UAAU,QAAQ,UAAU,KACpD;AACA,UAAO,KAAK,UAAU,MAAM,KAAK,eAAe;AAChD;;AAIF,MAAI,UAAU,UAAa,UAAU,QAAQ,UAAU,GACrD;AAIF,UAAQ,MAAM,MAAd;GACE,KAAK;AACH,QAAI,OAAO,UAAU,SACnB,QAAO,KAAK,UAAU,MAAM,KAAK,oBAAoB;AAEvD;GACF,KAAK;AACH,QAAI,OAAO,UAAU,YAAY,MAAM,MAAM,CAC3C,QAAO,KAAK,UAAU,MAAM,KAAK,oBAAoB;AAEvD;GACF,KAAK;AACH,QAAI,OAAO,UAAU,UACnB,QAAO,KAAK,UAAU,MAAM,KAAK,qBAAqB;AAExD;;;AAIN,QAAO;EAAE,OAAO,OAAO,WAAW;EAAG;EAAQ;;;;;AAM/C,SAAS,cACP,MACA,QACyB;CACzB,MAAM,SAAS,EAAE,GAAG,MAAM;AAE1B,MAAK,MAAM,SAAS,OAAO,OACzB,MACG,OAAO,MAAM,SAAS,UAAa,OAAO,MAAM,SAAS,SAC1D,MAAM,iBAAiB,OAEvB,QAAO,MAAM,OAAO,MAAM;AAI9B,QAAO;;AAGT,MAAa,gBAAgB,iBAAiB;CAI5C,MAAM,mBACH,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,QAAQ,EAAE,KAAK;GAAC;GAAS;GAAa;GAAW,CAAC,CAAC,UAAU;EAC7D,OAAO,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,IAAI,IAAI,CAAC,QAAQ,GAAG;EAC7C,QAAQ,EAAE,QAAQ,CAAC,IAAI,EAAE,CAAC,QAAQ,EAAE;EACpC,SAAS,EAAE,KAAK,CAAC,aAAa,YAAY,CAAC,CAAC,QAAQ,YAAY;EAChE,UAAU,EAAE,KAAK,CAAC,OAAO,OAAO,CAAC,CAAC,QAAQ,OAAO;EAClD,CAAC,CACH,CACA,MAAM,OAAO,EAAE,YAAY;EAC1B,MAAM,KAAK,aAAa;EAGxB,MAAM,aAAa,CAAC,GAAG,aAAa,eAAe,MAAM,aAAa,CAAC;AAEvE,MAAI,MAAM,OACR,YAAW,KAAK,GAAG,aAAa,QAAQ,MAAM,OAAO,CAAC;EAIxD,MAAM,UAAU,MAAM,GACnB,OAAO;GACN,IAAI,aAAa;GACjB,MAAM,aAAa;GACnB,QAAQ,aAAa;GACrB,aAAa,aAAa;GAC1B,WAAW,aAAa;GACxB,WAAW,aAAa;GACzB,CAAC,CACD,KAAK,aAAa,CAClB,MAAM,IAAI,GAAG,WAAW,CAAC,CACzB,QACC,MAAM,aAAa,SACf,KAAK,aAAa,MAAM,SAAS,GACjC,IAAI,aAAa,MAAM,SAAS,CACrC,CACA,MAAM,MAAM,MAAM,CAClB,OAAO,MAAM,OAAO;EAGvB,MAAM,CAAC,EAAE,WAAW,MAAM,GACvB,OAAO,EAAE,OAAO,GAAW,iBAAiB,CAAC,CAC7C,KAAK,aAAa,CAClB,MAAM,IAAI,GAAG,WAAW,CAAC;AAE5B,SAAO;GACL;GACA,OAAO;GACP,OAAO,MAAM;GACb,QAAQ,MAAM;GACf;GACD;CAKJ,SAAS,mBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,MAAM,OAAO,EAAE,YAAY;EAG1B,MAAM,CAAC,SAAS,MAFL,aAAa,CAGrB,QAAQ,CACR,KAAK,aAAa,CAClB,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,MAAM,EAAE;AAEX,MAAI,CAAC,MACH,OAAM,IAAI,MAAM,kBAAkB;AAGpC,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,cAAc,EAAE,QAAQ,CAAC,MAAM;EAC/B,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC;EACvC,QAAQ,EAAE,KAAK,CAAC,SAAS,YAAY,CAAC,CAAC,QAAQ,QAAQ;EACxD,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAClC,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,cAAc,MAAM,GACxB,OAAO,EAAE,QAAQ,YAAY,QAAQ,CAAC,CACtC,KAAK,YAAY,CACjB,MAAM,GAAG,YAAY,IAAI,MAAM,aAAa,CAAC,CAC7C,MAAM,EAAE;AAEX,MAAI,CAAC,WACH,OAAM,IAAI,MAAM,uBAAuB;EAGzC,MAAM,SAAS,WAAW;EAG1B,MAAM,mBAAmB,cAAc,MAAM,MAAM,OAAO;EAG1D,MAAM,aAAa,kBAAkB,kBAAkB,OAAO;AAC9D,MAAI,CAAC,WAAW,MACd,OAAM,IAAI,MAAM,sBAAsB,WAAW,OAAO,KAAK,KAAK,GAAG;EAGvE,MAAM,CAAC,SAAS,MAAM,GACnB,OAAO,aAAa,CACpB,OAAO;GACN,eAAe,MAAM;GACrB,MAAM;GACN,QAAQ,MAAM;GACd,aAAa,MAAM,WAAW,8BAAc,IAAI,MAAM,GAAG;GACzD,aAAa,IAAI,KAAK;GACtB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MACC,EAAE,OAAO;EACP,IAAI,EAAE,QAAQ,CAAC,MAAM;EACrB,MAAM,EAAE,OAAO,EAAE,QAAQ,EAAE,EAAE,SAAS,CAAC,CAAC,UAAU;EAClD,QAAQ,EAAE,KAAK;GAAC;GAAS;GAAa;GAAW,CAAC,CAAC,UAAU;EAC9D,CAAC,CACH,CACA,SAAS,OAAO,EAAE,OAAO,UAAU;EAClC,MAAM,KAAK,aAAa;EAGxB,MAAM,CAAC,SAAS,MAAM,GACnB,OAAO;GACN,OAAO;GACP,QAAQ,YAAY;GACrB,CAAC,CACD,KAAK,aAAa,CAClB,UAAU,aAAa,GAAG,aAAa,eAAe,YAAY,GAAG,CAAC,CACtE,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,MAAM,EAAE;AAEX,MAAI,CAAC,MACH,OAAM,IAAI,MAAM,kBAAkB;EAGpC,MAAM,SAAS,MAAM;EAGrB,MAAMC,UAAqD;GACzD,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB;AAED,MAAI,MAAM,MAAM;GAGd,MAAM,mBAAmB,cADN;IAAE,GAAG,MAAM,MAAM;IAAM,GAAG,MAAM;IAAM,EACN,OAAO;GAG1D,MAAM,aAAa,kBAAkB,kBAAkB,OAAO;AAC9D,OAAI,CAAC,WAAW,MACd,OAAM,IAAI,MAAM,sBAAsB,WAAW,OAAO,KAAK,KAAK,GAAG;AAGvE,WAAQ,OAAO;;AAGjB,MAAI,MAAM,QAAQ;AAChB,WAAQ,SAAS,MAAM;AAGvB,OACE,MAAM,WAAW,eACjB,MAAM,MAAM,WAAW,YAEvB,SAAQ,8BAAc,IAAI,MAAM;;EAIpC,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,aAAa,CACpB,IAAI,QAAQ,CACZ,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,SAAO;GACP;CAKJ,QAAQ,mBACL,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,YAAY;EAG7B,MAAM,CAAC,WAAW,MAFP,aAAa,CAGrB,OAAO,aAAa,CACpB,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,UAAU,EAAE,IAAI,aAAa,IAAI,CAAC;AAErC,MAAI,CAAC,QACH,OAAM,IAAI,MAAM,kBAAkB;AAGpC,SAAO,EAAE,SAAS,MAAM;GACxB;CAKJ,SAAS,mBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,SAAS,MAFL,aAAa,CAGrB,OAAO,aAAa,CACpB,IAAI;GACH,QAAQ;GACR,6BAAa,IAAI,MAAM;GACvB,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,MAAI,CAAC,MACH,OAAM,IAAI,MAAM,kBAAkB;AAGpC,SAAO;GACP;CAKJ,WAAW,mBACR,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,SAAS,MAFL,aAAa,CAGrB,OAAO,aAAa,CACpB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,MAAI,CAAC,MACH,OAAM,IAAI,MAAM,kBAAkB;AAGpC,SAAO;GACP;CAKJ,SAAS,mBACN,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,QAAQ,CAAC,MAAM,EAAE,CAAC,CAAC,CAC1C,SAAS,OAAO,EAAE,OAAO,UAAU;EAGlC,MAAM,CAAC,SAAS,MAFL,aAAa,CAGrB,OAAO,aAAa,CACpB,IAAI;GACH,QAAQ;GACR,2BAAW,IAAI,MAAM;GACrB,aAAa,IAAI,KAAK;GACvB,CAAC,CACD,MAAM,GAAG,aAAa,IAAI,MAAM,GAAG,CAAC,CACpC,WAAW;AAEd,MAAI,CAAC,MACH,OAAM,IAAI,MAAM,kBAAkB;AAGpC,SAAO;GACP;CAKJ,YAAY,mBACT,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CACpD,SAAS,OAAO,EAAE,YAAY;EAC7B,MAAM,KAAK,aAAa;EAExB,IAAI,eAAe;AAEnB,OAAK,MAAM,MAAM,MAAM,KAAK;GAC1B,MAAM,CAAC,WAAW,MAAM,GACrB,OAAO,aAAa,CACpB,MAAM,GAAG,aAAa,IAAI,GAAG,CAAC,CAC9B,UAAU,EAAE,IAAI,aAAa,IAAI,CAAC;AAErC,OAAI,QACF;;AAIJ,SAAO,EAAE,cAAc;GACvB;CACL,CAAC;;;;;;;ACxYF,MAAa,YAAY,iBAAiB;CAIxC,OAAO;CAKP,aAAa;CAKb,SAAS;CAKT,aAAa;CAKb,cAAc;CAKd,OAAO;CAKP,QAAQ,gBAAgB,YAAY;AAClC,SAAO;GACL,QAAQ;GACR,4BAAW,IAAI,MAAM,EAAC,aAAa;GACnC,SAAS;GACV;GACD;CAKF,IAAI,mBAAmB,OAAO,EAAE,UAAU;AACxC,SAAO;GACL,MAAM,IAAI;GACV,SAAS;IACP,IAAI,IAAI,QAAQ;IAChB,WAAW,IAAI,QAAQ;IACxB;GACF;GACD;CACH,CAAC;;;;;;;;ACxDF,MAAa,gBAAgB,OAAO,QAAuC;CACzE,IAAIC,YAA0B;CAC9B,IAAIC,SAAoB;AAExB,KAAI;EACF,MAAM,cAAc,MAAM,WAAW,IAAI;AAEzC,MAAI,aAAa,WAAW,aAAa,MAAM;AAC7C,eAAU;IACR,IAAI,YAAY,QAAQ;IACxB,OAAO,YAAY,QAAQ;IAC3B,WAAW,YAAY,QAAQ;IAC/B,WAAW,YAAY,QAAQ;IAC/B,WAAW,YAAY,QAAQ;IAC/B,WAAW,YAAY,QAAQ,aAAa;IAC5C,WAAW,YAAY,QAAQ,aAAa;IAC5C,QAAQ,YAAY,QAAQ;IAC7B;AAED,YAAO;IACL,IAAI,YAAY,KAAK;IACrB,MAAM,YAAY,KAAK;IACvB,OAAO,YAAY,KAAK;IACxB,eAAe,YAAY,KAAK;IAChC,OAAO,YAAY,KAAK,SAAS;IACjC,WAAW,YAAY,KAAK;IAC5B,WAAW,YAAY,KAAK;IAC7B;;UAEI,OAAO;AAEd,UAAQ,MAAM,2BAA2B,MAAM;;AAGjD,QAAO;EACL;EACA;EACA;EACD;;;;;AAMH,MAAa,oBAAoB,OAAO,QAAoC;AAC1E,QAAO,oBAAoB;EACzB,UAAU;EACV;EACA,QAAQ;EACR,qBAAqB,cAAc,IAAI;EACvC,UAAU,EAAE,MAAM,YAAY;AAC5B,WAAQ,MAAM,gBAAgB,KAAK,IAAI,MAAM;;EAEhD,CAAC;;;;;AChDJ,MAAMC,iBAAqC;CACzC,UAAU;CACV,UAAU;CACV,SAAS;CACT,MAAM;CACP;;;;;AAMD,MAAa,aAAa,YAA4C;CACpE,MAAMC,OAA2B;EAC/B,GAAG;EACH,UAAU,SAAS,YAAY,eAAe;EAC9C,UAAU,CAAC,CAAC,SAAS;EACrB,SAAS,CAAC,CAAC,SAAS;EACpB,MAAM,CAAC,CAAC,SAAS;EAClB;CAGD,IAAIC,cAAoD;CACxD,IAAI,cAAc;CAGlB,MAAM,oBAAoB,YAA2B;AACnD,MAAI,YAAa;AAEjB,MAAI,CAAC,YACH,gBAAe,YAAY;GAEzB,IAAIC,KAA2B;AAC/B,OAAI,SAAS,SACX,MAAK,MAAM,eAAe,QAAQ,SAAS;AAI7C,OAAI,SAAS,QACX,aAAY,QAAQ,QAAQ;AAI9B,OAAI,SAAS,QAAQ,GACnB,YAAW,IAAI;IACb,GAAG,QAAQ;IACX,cAAc,GAAG,KAAK,SAAS;IAChC,CAAC;AAGJ,iBAAc;AACd,UAAO;MACL;AAGN,QAAM;;CAGR,MAAM,MAAM,OAAO,QAAoC;AAErD,QAAM,mBAAmB;EAGzB,MAAM,EAAE,aADI,IAAI,IAAI,IAAI,IAAI;AAI5B,MAAI,SAAS,QAAQ,SAAS,WAAW,GAAG,KAAK,SAAS,WAAW,CAEnE,QADa,SAAS,CACV,QAAQ,IAAI;AAI1B,MAAI,SAAS,WAAW,GAAG,KAAK,SAAS,WAAW,CAClD,QAAO,kBAAkB,IAAI;AAI/B,MAAI,CADY,SAAS,WAAW,KAAK,SAAS,CAEhD,QAAO,SAAS,KAAK,EACnB,SACE,kFACH,CAAC;AAGJ,SAAO,MAAM,aAAa,KAAK,KAAK;;CAGtC,MAAM,OAAO,OAAO,QAAoC;AAEtD,QAAM,mBAAmB;EAEzB,MAAM,MAAM,IAAI,IAAI,IAAI,IAAI;EAC5B,MAAM,EAAE,aAAa;AAGrB,MAAI,SAAS,QAAQ,SAAS,WAAW,GAAG,KAAK,SAAS,WAAW,CAEnE,QADa,SAAS,CACV,QAAQ,IAAI;AAI1B,MAAI,SAAS,WAAW,GAAG,KAAK,SAAS,WAAW,CAClD,QAAO,kBAAkB,IAAI;AAI/B,MAAI,CADY,SAAS,WAAW,KAAK,SAAS,CAEhD,QAAO,SAAS,KAAK,EACnB,SACE,kFACH,CAAC;EAGJ,IAAIC,OAAgB;AACpB,MAAI;AACF,UAAO,MAAM,IAAI,MAAM;UACjB;AAIR,SAAO,SAAS,KAAK;GACnB,SAAS;GACT,QAAQ,IAAI;GACZ;GACA,OAAO,IAAI,aAAa,UAAU;GAClC;GACA,SAAS,OAAO,YAAY,IAAI,QAAQ,SAAS,CAAC;GACnD,CAAC;;AAGJ,QAAO;EAAE;EAAK;EAAM"}